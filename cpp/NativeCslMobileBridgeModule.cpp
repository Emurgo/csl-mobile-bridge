#include "NativeCslMobileBridgeModule.h"
#include "utils.h"
extern "C" {
    #include "react_native_haskell_shelley.h"
}

void throw_if_error(facebook::jsi::Runtime &rt, CharPtr ptr, const std::string &fn_name) {
    if(ptr != nullptr) {
        std::string str = ptr;
        charptr_free(&ptr);
        throw facebook::jsi::JSError(rt, fn_name + ": " + str);
    }
}

namespace facebook::react {

    NativeCslMobileBridgeModule::NativeCslMobileBridgeModule(std::shared_ptr <CallInvoker> jsInvoker)
            : NativeCslMobileBridgeCxxSpec(std::move(jsInvoker)) {}

    void NativeCslMobileBridgeModule::ptr_free_jsi(jsi::Runtime &rt, std::string ptr) {
        RPtr rptr = stringToRptr(ptr);
        rptr_free(&rptr);
    }

    void NativeCslMobileBridgeModule::init_jsi(jsi::Runtime &rt) {
        init_haskell_shelley_library();
    }

    std::string NativeCslMobileBridgeModule::calculate_ex_units_ceil_cost_jsi(jsi::Runtime &rt, std::string ex_units, std::string ex_unit_prices) {
        RPtr ex_units_mapped = stringToRptr(ex_units);
        RPtr ex_unit_prices_mapped = stringToRptr(ex_unit_prices);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = calculate_ex_units_ceil_cost(ex_units_mapped, ex_unit_prices_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.calculate_ex_units_ceil_cost");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::create_send_all_jsi(jsi::Runtime &rt, std::string address, std::string utxos, std::string config) {
        RPtr address_mapped = stringToRptr(address);
        RPtr utxos_mapped = stringToRptr(utxos);
        RPtr config_mapped = stringToRptr(config);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = create_send_all(address_mapped, utxos_mapped, config_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.create_send_all");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::decode_arbitrary_bytes_from_metadatum_jsi(jsi::Runtime &rt, std::string metadata) {
        RPtr metadata_mapped = stringToRptr(metadata);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = decode_arbitrary_bytes_from_metadatum(metadata_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "None.decode_arbitrary_bytes_from_metadatum");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::decode_metadatum_to_json_str_jsi(jsi::Runtime &rt, std::string metadatum, double schema) {
        RPtr metadatum_mapped = stringToRptr(metadatum);
        int32_t schema_mapped = static_cast<int32_t>(schema);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = decode_metadatum_to_json_str(metadatum_mapped, schema_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "None.decode_metadatum_to_json_str");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::decode_plutus_datum_to_json_str_jsi(jsi::Runtime &rt, std::string datum, double schema) {
        RPtr datum_mapped = stringToRptr(datum);
        int32_t schema_mapped = static_cast<int32_t>(schema);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = decode_plutus_datum_to_json_str(datum_mapped, schema_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "None.decode_plutus_datum_to_json_str");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::decrypt_with_password_jsi(jsi::Runtime &rt, std::string password, std::string data) {
        CharPtr password_mapped = stringToCharPtr(password);
        CharPtr data_mapped = stringToCharPtr(data);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = decrypt_with_password(password_mapped, data_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "None.decrypt_with_password");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::encode_arbitrary_bytes_as_metadatum_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = encode_arbitrary_bytes_as_metadatum(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.encode_arbitrary_bytes_as_metadatum");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::encode_json_str_to_metadatum_jsi(jsi::Runtime &rt, std::string json, double schema) {
        CharPtr json_mapped = stringToCharPtr(json);
        int32_t schema_mapped = static_cast<int32_t>(schema);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = encode_json_str_to_metadatum(json_mapped, schema_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.encode_json_str_to_metadatum");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::encode_json_str_to_native_script_jsi(jsi::Runtime &rt, std::string json, std::string self_xpub, double schema) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr self_xpub_mapped = stringToCharPtr(self_xpub);
        int32_t schema_mapped = static_cast<int32_t>(schema);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = encode_json_str_to_native_script(json_mapped, self_xpub_mapped, schema_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.encode_json_str_to_native_script");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::encode_json_str_to_plutus_datum_jsi(jsi::Runtime &rt, std::string json, double schema) {
        CharPtr json_mapped = stringToCharPtr(json);
        int32_t schema_mapped = static_cast<int32_t>(schema);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = encode_json_str_to_plutus_datum(json_mapped, schema_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.encode_json_str_to_plutus_datum");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::encrypt_with_password_jsi(jsi::Runtime &rt, std::string password, std::string salt, std::string nonce, std::string data) {
        CharPtr password_mapped = stringToCharPtr(password);
        CharPtr salt_mapped = stringToCharPtr(salt);
        CharPtr nonce_mapped = stringToCharPtr(nonce);
        CharPtr data_mapped = stringToCharPtr(data);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = encrypt_with_password(password_mapped, salt_mapped, nonce_mapped, data_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "None.encrypt_with_password");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::get_deposit_jsi(jsi::Runtime &rt, std::string txbody, std::string pool_deposit, std::string key_deposit) {
        RPtr txbody_mapped = stringToRptr(txbody);
        RPtr pool_deposit_mapped = stringToRptr(pool_deposit);
        RPtr key_deposit_mapped = stringToRptr(key_deposit);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = get_deposit(txbody_mapped, pool_deposit_mapped, key_deposit_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.get_deposit");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::get_implicit_input_jsi(jsi::Runtime &rt, std::string txbody, std::string pool_deposit, std::string key_deposit) {
        RPtr txbody_mapped = stringToRptr(txbody);
        RPtr pool_deposit_mapped = stringToRptr(pool_deposit);
        RPtr key_deposit_mapped = stringToRptr(key_deposit);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = get_implicit_input(txbody_mapped, pool_deposit_mapped, key_deposit_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.get_implicit_input");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::hash_auxiliary_data_jsi(jsi::Runtime &rt, std::string auxiliary_data) {
        RPtr auxiliary_data_mapped = stringToRptr(auxiliary_data);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = hash_auxiliary_data(auxiliary_data_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.hash_auxiliary_data");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::hash_plutus_data_jsi(jsi::Runtime &rt, std::string plutus_data) {
        RPtr plutus_data_mapped = stringToRptr(plutus_data);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = hash_plutus_data(plutus_data_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.hash_plutus_data");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::hash_script_data_jsi(jsi::Runtime &rt, std::string redeemers, std::string cost_models) {
        RPtr redeemers_mapped = stringToRptr(redeemers);
        RPtr cost_models_mapped = stringToRptr(cost_models);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = hash_script_data(redeemers_mapped, cost_models_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.hash_script_data");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::hash_script_data_with_datums_jsi(jsi::Runtime &rt, std::string redeemers, std::string cost_models, std::string datums) {
        RPtr redeemers_mapped = stringToRptr(redeemers);
        RPtr cost_models_mapped = stringToRptr(cost_models);
        RPtr datums_mapped = stringToRptr(datums);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = hash_script_data_with_datums(redeemers_mapped, cost_models_mapped, datums_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.hash_script_data_with_datums");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::hash_transaction_jsi(jsi::Runtime &rt, std::string tx_body) {
        RPtr tx_body_mapped = stringToRptr(tx_body);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = hash_transaction(tx_body_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.hash_transaction");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::make_daedalus_bootstrap_witness_jsi(jsi::Runtime &rt, std::string tx_body_hash, std::string addr, std::string key) {
        RPtr tx_body_hash_mapped = stringToRptr(tx_body_hash);
        RPtr addr_mapped = stringToRptr(addr);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = make_daedalus_bootstrap_witness(tx_body_hash_mapped, addr_mapped, key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.make_daedalus_bootstrap_witness");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::make_icarus_bootstrap_witness_jsi(jsi::Runtime &rt, std::string tx_body_hash, std::string addr, std::string key) {
        RPtr tx_body_hash_mapped = stringToRptr(tx_body_hash);
        RPtr addr_mapped = stringToRptr(addr);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = make_icarus_bootstrap_witness(tx_body_hash_mapped, addr_mapped, key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.make_icarus_bootstrap_witness");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::make_vkey_witness_jsi(jsi::Runtime &rt, std::string tx_body_hash, std::string sk) {
        RPtr tx_body_hash_mapped = stringToRptr(tx_body_hash);
        RPtr sk_mapped = stringToRptr(sk);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = make_vkey_witness(tx_body_hash_mapped, sk_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.make_vkey_witness");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::min_ada_for_output_jsi(jsi::Runtime &rt, std::string output, std::string data_cost) {
        RPtr output_mapped = stringToRptr(output);
        RPtr data_cost_mapped = stringToRptr(data_cost);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = min_ada_for_output(output_mapped, data_cost_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.min_ada_for_output");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::min_ada_required_jsi(jsi::Runtime &rt, std::string assets, bool has_data_hash, std::string coins_per_utxo_word) {
        RPtr assets_mapped = stringToRptr(assets);
        bool has_data_hash_mapped = static_cast<bool>(has_data_hash);
        RPtr coins_per_utxo_word_mapped = stringToRptr(coins_per_utxo_word);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = min_ada_required(assets_mapped, has_data_hash_mapped, coins_per_utxo_word_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.min_ada_required");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::min_fee_jsi(jsi::Runtime &rt, std::string tx, std::string linear_fee) {
        RPtr tx_mapped = stringToRptr(tx);
        RPtr linear_fee_mapped = stringToRptr(linear_fee);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = min_fee(tx_mapped, linear_fee_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.min_fee");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::min_script_fee_jsi(jsi::Runtime &rt, std::string tx, std::string ex_unit_prices) {
        RPtr tx_mapped = stringToRptr(tx);
        RPtr ex_unit_prices_mapped = stringToRptr(ex_unit_prices);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = min_script_fee(tx_mapped, ex_unit_prices_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "None.min_script_fee");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::address_from_bytes_jsi(jsi::Runtime &rt, std::string data) {
        auto data_mapped = base64ToBytes(data);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = address_from_bytes(data_mapped.data(), data_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Address.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::address_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = address_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Address.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::address_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = address_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Address.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::address_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = address_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Address.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::address_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = address_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Address.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::address_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = address_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Address.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::address_to_bech32_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = address_to_bech32(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Address.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::address_to_bech32_with_prefix_jsi(jsi::Runtime &rt, std::string self, std::string prefix) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr prefix_mapped = stringToCharPtr(prefix);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = address_to_bech32_with_prefix(self_mapped, prefix_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Address.to_bech32_with_prefix");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::address_from_bech32_jsi(jsi::Runtime &rt, std::string bech_str) {
        CharPtr bech_str_mapped = stringToCharPtr(bech_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = address_from_bech32(bech_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Address.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::address_network_id_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        address_network_id(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Address.network_id");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::anchor_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = anchor_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Anchor.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::anchor_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = anchor_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Anchor.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::anchor_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = anchor_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Anchor.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::anchor_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = anchor_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Anchor.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::anchor_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = anchor_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Anchor.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::anchor_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = anchor_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Anchor.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::anchor_url_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = anchor_url(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Anchor.url");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::anchor_anchor_data_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = anchor_anchor_data_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Anchor.anchor_data_hash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::anchor_new_jsi(jsi::Runtime &rt, std::string anchor_url, std::string anchor_data_hash) {
        RPtr anchor_url_mapped = stringToRptr(anchor_url);
        RPtr anchor_data_hash_mapped = stringToRptr(anchor_data_hash);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = anchor_new(anchor_url_mapped, anchor_data_hash_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Anchor.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::anchor_data_hash_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = anchor_data_hash_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AnchorDataHash.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::anchor_data_hash_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = anchor_data_hash_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "AnchorDataHash.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::anchor_data_hash_to_bech32_jsi(jsi::Runtime &rt, std::string self, std::string prefix) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr prefix_mapped = stringToCharPtr(prefix);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = anchor_data_hash_to_bech32(self_mapped, prefix_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "AnchorDataHash.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::anchor_data_hash_from_bech32_jsi(jsi::Runtime &rt, std::string bech_str) {
        CharPtr bech_str_mapped = stringToCharPtr(bech_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = anchor_data_hash_from_bech32(bech_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AnchorDataHash.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::anchor_data_hash_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = anchor_data_hash_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "AnchorDataHash.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::anchor_data_hash_from_hex_jsi(jsi::Runtime &rt, std::string hex) {
        CharPtr hex_mapped = stringToCharPtr(hex);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = anchor_data_hash_from_hex(hex_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AnchorDataHash.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::asset_name_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = asset_name_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "AssetName.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::asset_name_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = asset_name_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AssetName.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::asset_name_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = asset_name_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "AssetName.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::asset_name_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = asset_name_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AssetName.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::asset_name_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = asset_name_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "AssetName.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::asset_name_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = asset_name_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AssetName.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::asset_name_new_jsi(jsi::Runtime &rt, std::string name) {
        auto name_mapped = base64ToBytes(name);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = asset_name_new(name_mapped.data(), name_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AssetName.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::asset_name_name_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = asset_name_name(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "AssetName.name");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::asset_names_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = asset_names_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "AssetNames.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::asset_names_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = asset_names_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AssetNames.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::asset_names_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = asset_names_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "AssetNames.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::asset_names_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = asset_names_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AssetNames.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::asset_names_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = asset_names_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "AssetNames.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::asset_names_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = asset_names_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AssetNames.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::asset_names_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = asset_names_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AssetNames.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::asset_names_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        asset_names_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "AssetNames.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::asset_names_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = asset_names_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AssetNames.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::asset_names_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        asset_names_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "AssetNames.add");
    }

    std::string NativeCslMobileBridgeModule::assets_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = assets_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Assets.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::assets_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = assets_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Assets.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::assets_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = assets_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Assets.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::assets_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = assets_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Assets.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::assets_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = assets_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Assets.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::assets_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = assets_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Assets.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::assets_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = assets_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Assets.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::assets_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        assets_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Assets.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::assets_insert_jsi(jsi::Runtime &rt, std::string self, std::string key, std::string value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        RPtr value_mapped = stringToRptr(value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = assets_insert(self_mapped, key_mapped, value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Assets.insert");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::assets_get_jsi(jsi::Runtime &rt, std::string self, std::string key) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = assets_get(self_mapped, key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Assets.get");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::assets_keys_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = assets_keys(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Assets.keys");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::auxiliary_data_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = auxiliary_data_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryData.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::auxiliary_data_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = auxiliary_data_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryData.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::auxiliary_data_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = auxiliary_data_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryData.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::auxiliary_data_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = auxiliary_data_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryData.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::auxiliary_data_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = auxiliary_data_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryData.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::auxiliary_data_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = auxiliary_data_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryData.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::auxiliary_data_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = auxiliary_data_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryData.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::auxiliary_data_metadata_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = auxiliary_data_metadata(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryData.metadata");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::auxiliary_data_set_metadata_jsi(jsi::Runtime &rt, std::string self, std::string metadata) {
        RPtr self_mapped = stringToRptr(self);
        RPtr metadata_mapped = stringToRptr(metadata);
        CharPtr err = nullptr;
        auxiliary_data_set_metadata(self_mapped, metadata_mapped, &err);
        throw_if_error(rt, err, "AuxiliaryData.set_metadata");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::auxiliary_data_native_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = auxiliary_data_native_scripts(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryData.native_scripts");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::auxiliary_data_set_native_scripts_jsi(jsi::Runtime &rt, std::string self, std::string native_scripts) {
        RPtr self_mapped = stringToRptr(self);
        RPtr native_scripts_mapped = stringToRptr(native_scripts);
        CharPtr err = nullptr;
        auxiliary_data_set_native_scripts(self_mapped, native_scripts_mapped, &err);
        throw_if_error(rt, err, "AuxiliaryData.set_native_scripts");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::auxiliary_data_plutus_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = auxiliary_data_plutus_scripts(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryData.plutus_scripts");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::auxiliary_data_set_plutus_scripts_jsi(jsi::Runtime &rt, std::string self, std::string plutus_scripts) {
        RPtr self_mapped = stringToRptr(self);
        RPtr plutus_scripts_mapped = stringToRptr(plutus_scripts);
        CharPtr err = nullptr;
        auxiliary_data_set_plutus_scripts(self_mapped, plutus_scripts_mapped, &err);
        throw_if_error(rt, err, "AuxiliaryData.set_plutus_scripts");
    }

    bool NativeCslMobileBridgeModule::auxiliary_data_prefer_alonzo_format_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        auxiliary_data_prefer_alonzo_format(self_mapped, &ret, &err);
        throw_if_error(rt, err, "AuxiliaryData.prefer_alonzo_format");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::auxiliary_data_set_prefer_alonzo_format_jsi(jsi::Runtime &rt, std::string self, bool prefer) {
        RPtr self_mapped = stringToRptr(self);
        bool prefer_mapped = static_cast<bool>(prefer);
        CharPtr err = nullptr;
        auxiliary_data_set_prefer_alonzo_format(self_mapped, prefer_mapped, &err);
        throw_if_error(rt, err, "AuxiliaryData.set_prefer_alonzo_format");
    }

    std::string NativeCslMobileBridgeModule::auxiliary_data_hash_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = auxiliary_data_hash_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryDataHash.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::auxiliary_data_hash_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = auxiliary_data_hash_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryDataHash.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::auxiliary_data_hash_to_bech32_jsi(jsi::Runtime &rt, std::string self, std::string prefix) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr prefix_mapped = stringToCharPtr(prefix);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = auxiliary_data_hash_to_bech32(self_mapped, prefix_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryDataHash.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::auxiliary_data_hash_from_bech32_jsi(jsi::Runtime &rt, std::string bech_str) {
        CharPtr bech_str_mapped = stringToCharPtr(bech_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = auxiliary_data_hash_from_bech32(bech_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryDataHash.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::auxiliary_data_hash_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = auxiliary_data_hash_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryDataHash.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::auxiliary_data_hash_from_hex_jsi(jsi::Runtime &rt, std::string hex) {
        CharPtr hex_mapped = stringToCharPtr(hex);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = auxiliary_data_hash_from_hex(hex_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryDataHash.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::auxiliary_data_set_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = auxiliary_data_set_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryDataSet.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::auxiliary_data_set_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        auxiliary_data_set_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "AuxiliaryDataSet.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::auxiliary_data_set_insert_jsi(jsi::Runtime &rt, std::string self, double tx_index, std::string data) {
        RPtr self_mapped = stringToRptr(self);
        int64_t tx_index_mapped = static_cast<int64_t>(tx_index);
        RPtr data_mapped = stringToRptr(data);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = auxiliary_data_set_insert(self_mapped, tx_index_mapped, data_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryDataSet.insert");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::auxiliary_data_set_get_jsi(jsi::Runtime &rt, std::string self, double tx_index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t tx_index_mapped = static_cast<int64_t>(tx_index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = auxiliary_data_set_get(self_mapped, tx_index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryDataSet.get");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::auxiliary_data_set_indices_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = auxiliary_data_set_indices(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "AuxiliaryDataSet.indices");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::base_address_new_jsi(jsi::Runtime &rt, double network, std::string payment, std::string stake) {
        int64_t network_mapped = static_cast<int64_t>(network);
        RPtr payment_mapped = stringToRptr(payment);
        RPtr stake_mapped = stringToRptr(stake);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = base_address_new(network_mapped, payment_mapped, stake_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BaseAddress.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::base_address_payment_cred_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = base_address_payment_cred(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BaseAddress.payment_cred");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::base_address_stake_cred_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = base_address_stake_cred(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BaseAddress.stake_cred");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::base_address_to_address_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = base_address_to_address(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BaseAddress.to_address");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::base_address_from_address_jsi(jsi::Runtime &rt, std::string addr) {
        RPtr addr_mapped = stringToRptr(addr);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = base_address_from_address(addr_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BaseAddress.from_address");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::big_int_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = big_int_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "BigInt.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_int_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_int_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigInt.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_int_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = big_int_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "BigInt.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_int_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_int_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigInt.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_int_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = big_int_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "BigInt.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_int_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_int_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigInt.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::big_int_is_zero_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        big_int_is_zero(self_mapped, &ret, &err);
        throw_if_error(rt, err, "BigInt.is_zero");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::big_int_as_u64_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_int_as_u64(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigInt.as_u64");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::big_int_as_int_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_int_as_int(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigInt.as_int");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::big_int_from_str_jsi(jsi::Runtime &rt, std::string text) {
        CharPtr text_mapped = stringToCharPtr(text);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_int_from_str(text_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigInt.from_str");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_int_to_str_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = big_int_to_str(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "BigInt.to_str");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_int_add_jsi(jsi::Runtime &rt, std::string self, std::string other) {
        RPtr self_mapped = stringToRptr(self);
        RPtr other_mapped = stringToRptr(other);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_int_add(self_mapped, other_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigInt.add");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_int_mul_jsi(jsi::Runtime &rt, std::string self, std::string other) {
        RPtr self_mapped = stringToRptr(self);
        RPtr other_mapped = stringToRptr(other);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_int_mul(self_mapped, other_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigInt.mul");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_int_one_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_int_one(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigInt.one");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_int_increment_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_int_increment(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigInt.increment");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_int_div_ceil_jsi(jsi::Runtime &rt, std::string self, std::string other) {
        RPtr self_mapped = stringToRptr(self);
        RPtr other_mapped = stringToRptr(other);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_int_div_ceil(self_mapped, other_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigInt.div_ceil");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = big_num_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_num_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = big_num_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_num_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = big_num_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_num_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_from_str_jsi(jsi::Runtime &rt, std::string string) {
        CharPtr string_mapped = stringToCharPtr(string);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_num_from_str(string_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.from_str");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_to_str_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = big_num_to_str(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.to_str");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_zero_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_num_zero(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.zero");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_one_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_num_one(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.one");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::big_num_is_zero_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        big_num_is_zero(self_mapped, &ret, &err);
        throw_if_error(rt, err, "BigNum.is_zero");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_div_floor_jsi(jsi::Runtime &rt, std::string self, std::string other) {
        RPtr self_mapped = stringToRptr(self);
        RPtr other_mapped = stringToRptr(other);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_num_div_floor(self_mapped, other_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.div_floor");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_checked_mul_jsi(jsi::Runtime &rt, std::string self, std::string other) {
        RPtr self_mapped = stringToRptr(self);
        RPtr other_mapped = stringToRptr(other);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_num_checked_mul(self_mapped, other_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.checked_mul");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_checked_add_jsi(jsi::Runtime &rt, std::string self, std::string other) {
        RPtr self_mapped = stringToRptr(self);
        RPtr other_mapped = stringToRptr(other);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_num_checked_add(self_mapped, other_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.checked_add");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_checked_sub_jsi(jsi::Runtime &rt, std::string self, std::string other) {
        RPtr self_mapped = stringToRptr(self);
        RPtr other_mapped = stringToRptr(other);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_num_checked_sub(self_mapped, other_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.checked_sub");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_clamped_sub_jsi(jsi::Runtime &rt, std::string self, std::string other) {
        RPtr self_mapped = stringToRptr(self);
        RPtr other_mapped = stringToRptr(other);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_num_clamped_sub(self_mapped, other_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.clamped_sub");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::big_num_compare_jsi(jsi::Runtime &rt, std::string self, std::string rhs_value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr rhs_value_mapped = stringToRptr(rhs_value);
        CharPtr err = nullptr;
        int64_t ret;
        big_num_compare(self_mapped, rhs_value_mapped, &ret, &err);
        throw_if_error(rt, err, "BigNum.compare");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::big_num_less_than_jsi(jsi::Runtime &rt, std::string self, std::string rhs_value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr rhs_value_mapped = stringToRptr(rhs_value);
        CharPtr err = nullptr;
        bool ret;
        big_num_less_than(self_mapped, rhs_value_mapped, &ret, &err);
        throw_if_error(rt, err, "BigNum.less_than");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_max_value_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_num_max_value(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.max_value");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::big_num_max_jsi(jsi::Runtime &rt, std::string a, std::string b) {
        RPtr a_mapped = stringToRptr(a);
        RPtr b_mapped = stringToRptr(b);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = big_num_max(a_mapped, b_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BigNum.max");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_private_key_derive_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bip32_private_key_derive(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PrivateKey.derive");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_private_key_from_128_xprv_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bip32_private_key_from_128_xprv(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PrivateKey.from_128_xprv");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_private_key_to_128_xprv_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = bip32_private_key_to_128_xprv(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PrivateKey.to_128_xprv");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_private_key_generate_ed25519_bip32_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bip32_private_key_generate_ed25519_bip32(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PrivateKey.generate_ed25519_bip32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_private_key_to_raw_key_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bip32_private_key_to_raw_key(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PrivateKey.to_raw_key");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_private_key_to_public_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bip32_private_key_to_public(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PrivateKey.to_public");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_private_key_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bip32_private_key_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PrivateKey.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_private_key_as_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = bip32_private_key_as_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PrivateKey.as_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_private_key_from_bech32_jsi(jsi::Runtime &rt, std::string bech32_str) {
        CharPtr bech32_str_mapped = stringToCharPtr(bech32_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bip32_private_key_from_bech32(bech32_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PrivateKey.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_private_key_to_bech32_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = bip32_private_key_to_bech32(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PrivateKey.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_private_key_from_bip39_entropy_jsi(jsi::Runtime &rt, std::string entropy, std::string password) {
        auto entropy_mapped = base64ToBytes(entropy);
        auto password_mapped = base64ToBytes(password);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bip32_private_key_from_bip39_entropy(entropy_mapped.data(), entropy_mapped.size(), password_mapped.data(), password_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PrivateKey.from_bip39_entropy");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_private_key_chaincode_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = bip32_private_key_chaincode(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PrivateKey.chaincode");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_private_key_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = bip32_private_key_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PrivateKey.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_private_key_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bip32_private_key_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PrivateKey.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_public_key_derive_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bip32_public_key_derive(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PublicKey.derive");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_public_key_to_raw_key_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bip32_public_key_to_raw_key(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PublicKey.to_raw_key");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_public_key_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bip32_public_key_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PublicKey.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_public_key_as_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = bip32_public_key_as_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PublicKey.as_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_public_key_from_bech32_jsi(jsi::Runtime &rt, std::string bech32_str) {
        CharPtr bech32_str_mapped = stringToCharPtr(bech32_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bip32_public_key_from_bech32(bech32_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PublicKey.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_public_key_to_bech32_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = bip32_public_key_to_bech32(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PublicKey.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_public_key_chaincode_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = bip32_public_key_chaincode(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PublicKey.chaincode");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_public_key_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = bip32_public_key_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PublicKey.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bip32_public_key_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bip32_public_key_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Bip32PublicKey.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = block_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Block.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = block_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Block.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = block_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Block.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = block_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Block.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = block_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Block.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = block_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Block.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_header_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = block_header(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Block.header");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_transaction_bodies_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = block_transaction_bodies(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Block.transaction_bodies");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_transaction_witness_sets_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = block_transaction_witness_sets(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Block.transaction_witness_sets");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_auxiliary_data_set_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = block_auxiliary_data_set(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Block.auxiliary_data_set");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_invalid_transactions_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = block_invalid_transactions(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Block.invalid_transactions");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_new_jsi(jsi::Runtime &rt, std::string header, std::string transaction_bodies, std::string transaction_witness_sets, std::string auxiliary_data_set, std::string invalid_transactions) {
        RPtr header_mapped = stringToRptr(header);
        RPtr transaction_bodies_mapped = stringToRptr(transaction_bodies);
        RPtr transaction_witness_sets_mapped = stringToRptr(transaction_witness_sets);
        RPtr auxiliary_data_set_mapped = stringToRptr(auxiliary_data_set);
        CharPtr invalid_transactions_mapped = stringToCharPtr(invalid_transactions);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = block_new(header_mapped, transaction_bodies_mapped, transaction_witness_sets_mapped, auxiliary_data_set_mapped, invalid_transactions_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Block.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_hash_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = block_hash_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BlockHash.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_hash_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = block_hash_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "BlockHash.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_hash_to_bech32_jsi(jsi::Runtime &rt, std::string self, std::string prefix) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr prefix_mapped = stringToCharPtr(prefix);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = block_hash_to_bech32(self_mapped, prefix_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "BlockHash.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_hash_from_bech32_jsi(jsi::Runtime &rt, std::string bech_str) {
        CharPtr bech_str_mapped = stringToCharPtr(bech_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = block_hash_from_bech32(bech_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BlockHash.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_hash_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = block_hash_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "BlockHash.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::block_hash_from_hex_jsi(jsi::Runtime &rt, std::string hex) {
        CharPtr hex_mapped = stringToCharPtr(hex);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = block_hash_from_hex(hex_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BlockHash.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bootstrap_witness_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = bootstrap_witness_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "BootstrapWitness.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bootstrap_witness_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bootstrap_witness_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BootstrapWitness.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bootstrap_witness_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = bootstrap_witness_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "BootstrapWitness.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bootstrap_witness_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bootstrap_witness_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BootstrapWitness.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bootstrap_witness_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = bootstrap_witness_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "BootstrapWitness.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bootstrap_witness_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bootstrap_witness_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BootstrapWitness.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bootstrap_witness_vkey_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bootstrap_witness_vkey(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BootstrapWitness.vkey");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bootstrap_witness_signature_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bootstrap_witness_signature(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BootstrapWitness.signature");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bootstrap_witness_chain_code_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = bootstrap_witness_chain_code(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "BootstrapWitness.chain_code");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bootstrap_witness_attributes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = bootstrap_witness_attributes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "BootstrapWitness.attributes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bootstrap_witness_new_jsi(jsi::Runtime &rt, std::string vkey, std::string signature, std::string chain_code, std::string attributes) {
        RPtr vkey_mapped = stringToRptr(vkey);
        RPtr signature_mapped = stringToRptr(signature);
        auto chain_code_mapped = base64ToBytes(chain_code);
        auto attributes_mapped = base64ToBytes(attributes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bootstrap_witness_new(vkey_mapped, signature_mapped, chain_code_mapped.data(), chain_code_mapped.size(), attributes_mapped.data(), attributes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BootstrapWitness.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bootstrap_witnesses_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bootstrap_witnesses_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BootstrapWitnesses.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::bootstrap_witnesses_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bootstrap_witnesses_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "BootstrapWitnesses.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::bootstrap_witnesses_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = bootstrap_witnesses_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "BootstrapWitnesses.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::bootstrap_witnesses_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        bootstrap_witnesses_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "BootstrapWitnesses.add");
    }

    std::string NativeCslMobileBridgeModule::byron_address_to_base58_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = byron_address_to_base58(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ByronAddress.to_base58");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::byron_address_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = byron_address_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ByronAddress.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::byron_address_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = byron_address_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ByronAddress.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::byron_address_byron_protocol_magic_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        byron_address_byron_protocol_magic(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ByronAddress.byron_protocol_magic");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::byron_address_attributes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = byron_address_attributes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ByronAddress.attributes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::byron_address_network_id_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        byron_address_network_id(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ByronAddress.network_id");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::byron_address_from_base58_jsi(jsi::Runtime &rt, std::string s) {
        CharPtr s_mapped = stringToCharPtr(s);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = byron_address_from_base58(s_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ByronAddress.from_base58");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::byron_address_icarus_from_key_jsi(jsi::Runtime &rt, std::string key, double protocol_magic) {
        RPtr key_mapped = stringToRptr(key);
        int64_t protocol_magic_mapped = static_cast<int64_t>(protocol_magic);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = byron_address_icarus_from_key(key_mapped, protocol_magic_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ByronAddress.icarus_from_key");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::byron_address_is_valid_jsi(jsi::Runtime &rt, std::string s) {
        CharPtr s_mapped = stringToCharPtr(s);
        CharPtr err = nullptr;
        bool ret;
        byron_address_is_valid(s_mapped, &ret, &err);
        throw_if_error(rt, err, "ByronAddress.is_valid");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::byron_address_to_address_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = byron_address_to_address(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ByronAddress.to_address");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::byron_address_from_address_jsi(jsi::Runtime &rt, std::string addr) {
        RPtr addr_mapped = stringToRptr(addr);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = byron_address_from_address(addr_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ByronAddress.from_address");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::certificate_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = certificate_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = certificate_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = certificate_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_stake_registration_jsi(jsi::Runtime &rt, std::string stake_registration) {
        RPtr stake_registration_mapped = stringToRptr(stake_registration);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_stake_registration(stake_registration_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_stake_registration");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_stake_deregistration_jsi(jsi::Runtime &rt, std::string stake_deregistration) {
        RPtr stake_deregistration_mapped = stringToRptr(stake_deregistration);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_stake_deregistration(stake_deregistration_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_stake_deregistration");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_stake_delegation_jsi(jsi::Runtime &rt, std::string stake_delegation) {
        RPtr stake_delegation_mapped = stringToRptr(stake_delegation);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_stake_delegation(stake_delegation_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_stake_delegation");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_pool_registration_jsi(jsi::Runtime &rt, std::string pool_registration) {
        RPtr pool_registration_mapped = stringToRptr(pool_registration);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_pool_registration(pool_registration_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_pool_registration");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_pool_retirement_jsi(jsi::Runtime &rt, std::string pool_retirement) {
        RPtr pool_retirement_mapped = stringToRptr(pool_retirement);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_pool_retirement(pool_retirement_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_pool_retirement");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_genesis_key_delegation_jsi(jsi::Runtime &rt, std::string genesis_key_delegation) {
        RPtr genesis_key_delegation_mapped = stringToRptr(genesis_key_delegation);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_genesis_key_delegation(genesis_key_delegation_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_genesis_key_delegation");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_move_instantaneous_rewards_cert_jsi(jsi::Runtime &rt, std::string move_instantaneous_rewards_cert) {
        RPtr move_instantaneous_rewards_cert_mapped = stringToRptr(move_instantaneous_rewards_cert);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_move_instantaneous_rewards_cert(move_instantaneous_rewards_cert_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_move_instantaneous_rewards_cert");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_committee_hot_auth_jsi(jsi::Runtime &rt, std::string committee_hot_auth) {
        RPtr committee_hot_auth_mapped = stringToRptr(committee_hot_auth);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_committee_hot_auth(committee_hot_auth_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_committee_hot_auth");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_committee_cold_resign_jsi(jsi::Runtime &rt, std::string committee_cold_resign) {
        RPtr committee_cold_resign_mapped = stringToRptr(committee_cold_resign);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_committee_cold_resign(committee_cold_resign_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_committee_cold_resign");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_drep_deregistration_jsi(jsi::Runtime &rt, std::string drep_deregistration) {
        RPtr drep_deregistration_mapped = stringToRptr(drep_deregistration);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_drep_deregistration(drep_deregistration_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_drep_deregistration");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_drep_registration_jsi(jsi::Runtime &rt, std::string drep_registration) {
        RPtr drep_registration_mapped = stringToRptr(drep_registration);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_drep_registration(drep_registration_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_drep_registration");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_drep_update_jsi(jsi::Runtime &rt, std::string drep_update) {
        RPtr drep_update_mapped = stringToRptr(drep_update);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_drep_update(drep_update_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_drep_update");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_stake_and_vote_delegation_jsi(jsi::Runtime &rt, std::string stake_and_vote_delegation) {
        RPtr stake_and_vote_delegation_mapped = stringToRptr(stake_and_vote_delegation);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_stake_and_vote_delegation(stake_and_vote_delegation_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_stake_and_vote_delegation");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_stake_registration_and_delegation_jsi(jsi::Runtime &rt, std::string stake_registration_and_delegation) {
        RPtr stake_registration_and_delegation_mapped = stringToRptr(stake_registration_and_delegation);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_stake_registration_and_delegation(stake_registration_and_delegation_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_stake_registration_and_delegation");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_stake_vote_registration_and_delegation_jsi(jsi::Runtime &rt, std::string stake_vote_registration_and_delegation) {
        RPtr stake_vote_registration_and_delegation_mapped = stringToRptr(stake_vote_registration_and_delegation);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_stake_vote_registration_and_delegation(stake_vote_registration_and_delegation_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_stake_vote_registration_and_delegation");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_vote_delegation_jsi(jsi::Runtime &rt, std::string vote_delegation) {
        RPtr vote_delegation_mapped = stringToRptr(vote_delegation);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_vote_delegation(vote_delegation_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_vote_delegation");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificate_new_vote_registration_and_delegation_jsi(jsi::Runtime &rt, std::string vote_registration_and_delegation) {
        RPtr vote_registration_and_delegation_mapped = stringToRptr(vote_registration_and_delegation);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_new_vote_registration_and_delegation(vote_registration_and_delegation_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.new_vote_registration_and_delegation");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::certificate_kind_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int32_t ret;
        certificate_kind(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Certificate.kind");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_stake_registration_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_stake_registration(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_stake_registration");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_stake_deregistration_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_stake_deregistration(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_stake_deregistration");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_stake_delegation_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_stake_delegation(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_stake_delegation");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_pool_registration_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_pool_registration(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_pool_registration");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_pool_retirement_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_pool_retirement(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_pool_retirement");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_genesis_key_delegation_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_genesis_key_delegation(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_genesis_key_delegation");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_move_instantaneous_rewards_cert_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_move_instantaneous_rewards_cert(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_move_instantaneous_rewards_cert");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_committee_hot_auth_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_committee_hot_auth(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_committee_hot_auth");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_committee_cold_resign_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_committee_cold_resign(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_committee_cold_resign");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_drep_deregistration_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_drep_deregistration(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_drep_deregistration");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_drep_registration_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_drep_registration(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_drep_registration");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_drep_update_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_drep_update(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_drep_update");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_stake_and_vote_delegation_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_stake_and_vote_delegation(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_stake_and_vote_delegation");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_stake_registration_and_delegation_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_stake_registration_and_delegation(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_stake_registration_and_delegation");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_stake_vote_registration_and_delegation_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_stake_vote_registration_and_delegation(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_stake_vote_registration_and_delegation");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_vote_delegation_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_vote_delegation(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_vote_delegation");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::certificate_as_vote_registration_and_delegation_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificate_as_vote_registration_and_delegation(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificate.as_vote_registration_and_delegation");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    bool NativeCslMobileBridgeModule::certificate_has_required_script_witness_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        certificate_has_required_script_witness(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Certificate.has_required_script_witness");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificates_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = certificates_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificates.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificates_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificates_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificates.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificates_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = certificates_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificates.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificates_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificates_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificates.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificates_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = certificates_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificates.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificates_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificates_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificates.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificates_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificates_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificates.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::certificates_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        certificates_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Certificates.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificates_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificates_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Certificates.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::certificates_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        certificates_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "Certificates.add");
    }

    std::string NativeCslMobileBridgeModule::certificates_builder_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificates_builder_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CertificatesBuilder.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::certificates_builder_add_jsi(jsi::Runtime &rt, std::string self, std::string cert) {
        RPtr self_mapped = stringToRptr(self);
        RPtr cert_mapped = stringToRptr(cert);
        CharPtr err = nullptr;
        certificates_builder_add(self_mapped, cert_mapped, &err);
        throw_if_error(rt, err, "CertificatesBuilder.add");
    }

    void NativeCslMobileBridgeModule::certificates_builder_add_with_plutus_witness_jsi(jsi::Runtime &rt, std::string self, std::string cert, std::string witness) {
        RPtr self_mapped = stringToRptr(self);
        RPtr cert_mapped = stringToRptr(cert);
        RPtr witness_mapped = stringToRptr(witness);
        CharPtr err = nullptr;
        certificates_builder_add_with_plutus_witness(self_mapped, cert_mapped, witness_mapped, &err);
        throw_if_error(rt, err, "CertificatesBuilder.add_with_plutus_witness");
    }

    void NativeCslMobileBridgeModule::certificates_builder_add_with_native_script_jsi(jsi::Runtime &rt, std::string self, std::string cert, std::string native_script_source) {
        RPtr self_mapped = stringToRptr(self);
        RPtr cert_mapped = stringToRptr(cert);
        RPtr native_script_source_mapped = stringToRptr(native_script_source);
        CharPtr err = nullptr;
        certificates_builder_add_with_native_script(self_mapped, cert_mapped, native_script_source_mapped, &err);
        throw_if_error(rt, err, "CertificatesBuilder.add_with_native_script");
    }

    std::string NativeCslMobileBridgeModule::certificates_builder_get_plutus_witnesses_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificates_builder_get_plutus_witnesses(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CertificatesBuilder.get_plutus_witnesses");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificates_builder_get_ref_inputs_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificates_builder_get_ref_inputs(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CertificatesBuilder.get_ref_inputs");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificates_builder_get_native_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificates_builder_get_native_scripts(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CertificatesBuilder.get_native_scripts");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificates_builder_get_certificates_refund_jsi(jsi::Runtime &rt, std::string self, std::string pool_deposit, std::string key_deposit) {
        RPtr self_mapped = stringToRptr(self);
        RPtr pool_deposit_mapped = stringToRptr(pool_deposit);
        RPtr key_deposit_mapped = stringToRptr(key_deposit);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificates_builder_get_certificates_refund(self_mapped, pool_deposit_mapped, key_deposit_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CertificatesBuilder.get_certificates_refund");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificates_builder_get_certificates_deposit_jsi(jsi::Runtime &rt, std::string self, std::string pool_deposit, std::string key_deposit) {
        RPtr self_mapped = stringToRptr(self);
        RPtr pool_deposit_mapped = stringToRptr(pool_deposit);
        RPtr key_deposit_mapped = stringToRptr(key_deposit);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificates_builder_get_certificates_deposit(self_mapped, pool_deposit_mapped, key_deposit_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CertificatesBuilder.get_certificates_deposit");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::certificates_builder_has_plutus_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        certificates_builder_has_plutus_scripts(self_mapped, &ret, &err);
        throw_if_error(rt, err, "CertificatesBuilder.has_plutus_scripts");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::certificates_builder_build_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = certificates_builder_build(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CertificatesBuilder.build");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = committee_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Committee.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Committee.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = committee_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Committee.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Committee.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = committee_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Committee.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Committee.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_new_jsi(jsi::Runtime &rt, std::string quorum_threshold) {
        RPtr quorum_threshold_mapped = stringToRptr(quorum_threshold);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_new(quorum_threshold_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Committee.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_members_keys_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_members_keys(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Committee.members_keys");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_quorum_threshold_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_quorum_threshold(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Committee.quorum_threshold");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::committee_add_member_jsi(jsi::Runtime &rt, std::string self, std::string committee_cold_credential, double epoch) {
        RPtr self_mapped = stringToRptr(self);
        RPtr committee_cold_credential_mapped = stringToRptr(committee_cold_credential);
        int64_t epoch_mapped = static_cast<int64_t>(epoch);
        CharPtr err = nullptr;
        committee_add_member(self_mapped, committee_cold_credential_mapped, epoch_mapped, &err);
        throw_if_error(rt, err, "Committee.add_member");
    }

    std::optional<double> NativeCslMobileBridgeModule::committee_get_member_epoch_jsi(jsi::Runtime &rt, std::string self, std::string committee_cold_credential) {
        RPtr self_mapped = stringToRptr(self);
        RPtr committee_cold_credential_mapped = stringToRptr(committee_cold_credential);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = committee_get_member_epoch(self_mapped, committee_cold_credential_mapped, &ret, &err);
        throw_if_error(rt, err, "Committee.get_member_epoch");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::committee_cold_resign_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = committee_cold_resign_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeColdResign.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_cold_resign_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_cold_resign_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeColdResign.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_cold_resign_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = committee_cold_resign_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeColdResign.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_cold_resign_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_cold_resign_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeColdResign.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_cold_resign_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = committee_cold_resign_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeColdResign.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_cold_resign_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_cold_resign_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeColdResign.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_cold_resign_committee_cold_key_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_cold_resign_committee_cold_key(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeColdResign.committee_cold_key");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::committee_cold_resign_anchor_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_cold_resign_anchor(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeColdResign.anchor");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::committee_cold_resign_new_jsi(jsi::Runtime &rt, std::string committee_cold_key) {
        RPtr committee_cold_key_mapped = stringToRptr(committee_cold_key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_cold_resign_new(committee_cold_key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeColdResign.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_cold_resign_new_with_anchor_jsi(jsi::Runtime &rt, std::string committee_cold_key, std::string anchor) {
        RPtr committee_cold_key_mapped = stringToRptr(committee_cold_key);
        RPtr anchor_mapped = stringToRptr(anchor);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_cold_resign_new_with_anchor(committee_cold_key_mapped, anchor_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeColdResign.new_with_anchor");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::committee_cold_resign_has_script_credentials_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        committee_cold_resign_has_script_credentials(self_mapped, &ret, &err);
        throw_if_error(rt, err, "CommitteeColdResign.has_script_credentials");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_hot_auth_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = committee_hot_auth_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeHotAuth.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_hot_auth_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_hot_auth_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeHotAuth.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_hot_auth_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = committee_hot_auth_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeHotAuth.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_hot_auth_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_hot_auth_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeHotAuth.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_hot_auth_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = committee_hot_auth_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeHotAuth.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_hot_auth_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_hot_auth_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeHotAuth.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_hot_auth_committee_cold_key_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_hot_auth_committee_cold_key(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeHotAuth.committee_cold_key");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_hot_auth_committee_hot_key_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_hot_auth_committee_hot_key(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeHotAuth.committee_hot_key");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::committee_hot_auth_new_jsi(jsi::Runtime &rt, std::string committee_cold_key, std::string committee_hot_key) {
        RPtr committee_cold_key_mapped = stringToRptr(committee_cold_key);
        RPtr committee_hot_key_mapped = stringToRptr(committee_hot_key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = committee_hot_auth_new(committee_cold_key_mapped, committee_hot_key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CommitteeHotAuth.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::committee_hot_auth_has_script_credentials_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        committee_hot_auth_has_script_credentials(self_mapped, &ret, &err);
        throw_if_error(rt, err, "CommitteeHotAuth.has_script_credentials");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::constitution_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = constitution_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Constitution.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::constitution_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = constitution_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Constitution.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::constitution_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = constitution_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Constitution.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::constitution_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = constitution_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Constitution.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::constitution_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = constitution_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Constitution.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::constitution_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = constitution_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Constitution.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::constitution_anchor_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = constitution_anchor(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Constitution.anchor");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::constitution_script_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = constitution_script_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Constitution.script_hash");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::constitution_new_jsi(jsi::Runtime &rt, std::string anchor) {
        RPtr anchor_mapped = stringToRptr(anchor);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = constitution_new(anchor_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Constitution.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::constitution_new_with_script_hash_jsi(jsi::Runtime &rt, std::string anchor, std::string script_hash) {
        RPtr anchor_mapped = stringToRptr(anchor);
        RPtr script_hash_mapped = stringToRptr(script_hash);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = constitution_new_with_script_hash(anchor_mapped, script_hash_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Constitution.new_with_script_hash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::constr_plutus_data_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = constr_plutus_data_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ConstrPlutusData.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::constr_plutus_data_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = constr_plutus_data_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ConstrPlutusData.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::constr_plutus_data_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = constr_plutus_data_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ConstrPlutusData.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::constr_plutus_data_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = constr_plutus_data_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ConstrPlutusData.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::constr_plutus_data_alternative_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = constr_plutus_data_alternative(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ConstrPlutusData.alternative");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::constr_plutus_data_data_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = constr_plutus_data_data(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ConstrPlutusData.data");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::constr_plutus_data_new_jsi(jsi::Runtime &rt, std::string alternative, std::string data) {
        RPtr alternative_mapped = stringToRptr(alternative);
        RPtr data_mapped = stringToRptr(data);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = constr_plutus_data_new(alternative_mapped, data_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ConstrPlutusData.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::cost_model_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = cost_model_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "CostModel.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::cost_model_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = cost_model_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CostModel.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::cost_model_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = cost_model_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "CostModel.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::cost_model_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = cost_model_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CostModel.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::cost_model_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = cost_model_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "CostModel.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::cost_model_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = cost_model_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CostModel.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::cost_model_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = cost_model_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CostModel.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::cost_model_set_jsi(jsi::Runtime &rt, std::string self, double operation, std::string cost) {
        RPtr self_mapped = stringToRptr(self);
        int64_t operation_mapped = static_cast<int64_t>(operation);
        RPtr cost_mapped = stringToRptr(cost);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = cost_model_set(self_mapped, operation_mapped, cost_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CostModel.set");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::cost_model_get_jsi(jsi::Runtime &rt, std::string self, double operation) {
        RPtr self_mapped = stringToRptr(self);
        int64_t operation_mapped = static_cast<int64_t>(operation);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = cost_model_get(self_mapped, operation_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "CostModel.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::cost_model_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        cost_model_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "CostModel.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::costmdls_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = costmdls_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Costmdls.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::costmdls_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = costmdls_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Costmdls.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::costmdls_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = costmdls_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Costmdls.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::costmdls_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = costmdls_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Costmdls.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::costmdls_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = costmdls_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Costmdls.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::costmdls_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = costmdls_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Costmdls.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::costmdls_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = costmdls_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Costmdls.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::costmdls_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        costmdls_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Costmdls.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::costmdls_insert_jsi(jsi::Runtime &rt, std::string self, std::string key, std::string value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        RPtr value_mapped = stringToRptr(value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = costmdls_insert(self_mapped, key_mapped, value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Costmdls.insert");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::costmdls_get_jsi(jsi::Runtime &rt, std::string self, std::string key) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = costmdls_get(self_mapped, key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Costmdls.get");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::costmdls_keys_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = costmdls_keys(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Costmdls.keys");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::costmdls_retain_language_versions_jsi(jsi::Runtime &rt, std::string self, std::string languages) {
        RPtr self_mapped = stringToRptr(self);
        RPtr languages_mapped = stringToRptr(languages);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = costmdls_retain_language_versions(self_mapped, languages_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Costmdls.retain_language_versions");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::credential_from_keyhash_jsi(jsi::Runtime &rt, std::string hash) {
        RPtr hash_mapped = stringToRptr(hash);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = credential_from_keyhash(hash_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Credential.from_keyhash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::credential_from_scripthash_jsi(jsi::Runtime &rt, std::string hash) {
        RPtr hash_mapped = stringToRptr(hash);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = credential_from_scripthash(hash_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Credential.from_scripthash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::credential_to_keyhash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = credential_to_keyhash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Credential.to_keyhash");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::credential_to_scripthash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = credential_to_scripthash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Credential.to_scripthash");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    double NativeCslMobileBridgeModule::credential_kind_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int32_t ret;
        credential_kind(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Credential.kind");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::credential_has_script_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        credential_has_script_hash(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Credential.has_script_hash");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::credential_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = credential_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Credential.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::credential_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = credential_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Credential.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::credential_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = credential_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Credential.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::credential_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = credential_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Credential.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::credential_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = credential_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Credential.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::credential_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = credential_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Credential.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::credentials_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = credentials_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Credentials.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::credentials_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = credentials_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Credentials.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::credentials_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = credentials_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Credentials.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::credentials_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = credentials_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Credentials.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::credentials_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = credentials_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Credentials.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::credentials_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = credentials_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Credentials.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::credentials_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = credentials_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Credentials.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::credentials_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        credentials_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Credentials.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::credentials_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = credentials_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Credentials.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::credentials_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        credentials_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "Credentials.add");
    }

    std::string NativeCslMobileBridgeModule::d_n_s_record_aor_a_a_a_a_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = d_n_s_record_aor_a_a_a_a_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "DNSRecordAorAAAA.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_n_s_record_aor_a_a_a_a_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_n_s_record_aor_a_a_a_a_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DNSRecordAorAAAA.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_n_s_record_aor_a_a_a_a_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = d_n_s_record_aor_a_a_a_a_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DNSRecordAorAAAA.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_n_s_record_aor_a_a_a_a_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_n_s_record_aor_a_a_a_a_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DNSRecordAorAAAA.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_n_s_record_aor_a_a_a_a_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = d_n_s_record_aor_a_a_a_a_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DNSRecordAorAAAA.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_n_s_record_aor_a_a_a_a_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_n_s_record_aor_a_a_a_a_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DNSRecordAorAAAA.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_n_s_record_aor_a_a_a_a_new_jsi(jsi::Runtime &rt, std::string dns_name) {
        CharPtr dns_name_mapped = stringToCharPtr(dns_name);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_n_s_record_aor_a_a_a_a_new(dns_name_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DNSRecordAorAAAA.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_n_s_record_aor_a_a_a_a_record_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = d_n_s_record_aor_a_a_a_a_record(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DNSRecordAorAAAA.record");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_n_s_record_s_r_v_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = d_n_s_record_s_r_v_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "DNSRecordSRV.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_n_s_record_s_r_v_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_n_s_record_s_r_v_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DNSRecordSRV.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_n_s_record_s_r_v_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = d_n_s_record_s_r_v_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DNSRecordSRV.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_n_s_record_s_r_v_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_n_s_record_s_r_v_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DNSRecordSRV.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_n_s_record_s_r_v_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = d_n_s_record_s_r_v_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DNSRecordSRV.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_n_s_record_s_r_v_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_n_s_record_s_r_v_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DNSRecordSRV.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_n_s_record_s_r_v_new_jsi(jsi::Runtime &rt, std::string dns_name) {
        CharPtr dns_name_mapped = stringToCharPtr(dns_name);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_n_s_record_s_r_v_new(dns_name_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DNSRecordSRV.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_n_s_record_s_r_v_record_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = d_n_s_record_s_r_v_record(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DNSRecordSRV.record");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_rep_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = d_rep_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "DRep.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_rep_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_rep_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DRep.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_rep_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = d_rep_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DRep.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_rep_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_rep_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DRep.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_rep_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = d_rep_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DRep.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_rep_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_rep_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DRep.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_rep_new_key_hash_jsi(jsi::Runtime &rt, std::string key_hash) {
        RPtr key_hash_mapped = stringToRptr(key_hash);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_rep_new_key_hash(key_hash_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DRep.new_key_hash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_rep_new_script_hash_jsi(jsi::Runtime &rt, std::string script_hash) {
        RPtr script_hash_mapped = stringToRptr(script_hash);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_rep_new_script_hash(script_hash_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DRep.new_script_hash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_rep_new_always_abstain_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_rep_new_always_abstain(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DRep.new_always_abstain");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::d_rep_new_always_no_confidence_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_rep_new_always_no_confidence(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DRep.new_always_no_confidence");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::d_rep_kind_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int32_t ret;
        d_rep_kind(self_mapped, &ret, &err);
        throw_if_error(rt, err, "DRep.kind");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::d_rep_to_key_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_rep_to_key_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DRep.to_key_hash");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::d_rep_to_script_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = d_rep_to_script_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DRep.to_script_hash");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::data_cost_new_coins_per_word_jsi(jsi::Runtime &rt, std::string coins_per_word) {
        RPtr coins_per_word_mapped = stringToRptr(coins_per_word);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = data_cost_new_coins_per_word(coins_per_word_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DataCost.new_coins_per_word");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::data_cost_new_coins_per_byte_jsi(jsi::Runtime &rt, std::string coins_per_byte) {
        RPtr coins_per_byte_mapped = stringToRptr(coins_per_byte);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = data_cost_new_coins_per_byte(coins_per_byte_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DataCost.new_coins_per_byte");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::data_cost_coins_per_byte_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = data_cost_coins_per_byte(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DataCost.coins_per_byte");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::data_hash_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = data_hash_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DataHash.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::data_hash_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = data_hash_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "DataHash.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::data_hash_to_bech32_jsi(jsi::Runtime &rt, std::string self, std::string prefix) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr prefix_mapped = stringToCharPtr(prefix);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = data_hash_to_bech32(self_mapped, prefix_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DataHash.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::data_hash_from_bech32_jsi(jsi::Runtime &rt, std::string bech_str) {
        CharPtr bech_str_mapped = stringToCharPtr(bech_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = data_hash_from_bech32(bech_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DataHash.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::data_hash_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = data_hash_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DataHash.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::data_hash_from_hex_jsi(jsi::Runtime &rt, std::string hex) {
        CharPtr hex_mapped = stringToCharPtr(hex);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = data_hash_from_hex(hex_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DataHash.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::datum_source_new_jsi(jsi::Runtime &rt, std::string datum) {
        RPtr datum_mapped = stringToRptr(datum);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = datum_source_new(datum_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DatumSource.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::datum_source_new_ref_input_jsi(jsi::Runtime &rt, std::string input) {
        RPtr input_mapped = stringToRptr(input);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = datum_source_new_ref_input(input_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DatumSource.new_ref_input");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_deregistration_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = drep_deregistration_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepDeregistration.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_deregistration_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_deregistration_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepDeregistration.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_deregistration_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = drep_deregistration_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepDeregistration.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_deregistration_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_deregistration_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepDeregistration.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_deregistration_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = drep_deregistration_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepDeregistration.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_deregistration_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_deregistration_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepDeregistration.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_deregistration_voting_credential_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_deregistration_voting_credential(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepDeregistration.voting_credential");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_deregistration_coin_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_deregistration_coin(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepDeregistration.coin");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_deregistration_new_jsi(jsi::Runtime &rt, std::string voting_credential, std::string coin) {
        RPtr voting_credential_mapped = stringToRptr(voting_credential);
        RPtr coin_mapped = stringToRptr(coin);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_deregistration_new(voting_credential_mapped, coin_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepDeregistration.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::drep_deregistration_has_script_credentials_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        drep_deregistration_has_script_credentials(self_mapped, &ret, &err);
        throw_if_error(rt, err, "DrepDeregistration.has_script_credentials");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_registration_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = drep_registration_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepRegistration.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_registration_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_registration_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepRegistration.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_registration_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = drep_registration_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepRegistration.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_registration_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_registration_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepRegistration.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_registration_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = drep_registration_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepRegistration.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_registration_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_registration_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepRegistration.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_registration_voting_credential_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_registration_voting_credential(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepRegistration.voting_credential");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_registration_coin_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_registration_coin(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepRegistration.coin");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::drep_registration_anchor_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_registration_anchor(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepRegistration.anchor");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::drep_registration_new_jsi(jsi::Runtime &rt, std::string voting_credential, std::string coin) {
        RPtr voting_credential_mapped = stringToRptr(voting_credential);
        RPtr coin_mapped = stringToRptr(coin);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_registration_new(voting_credential_mapped, coin_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepRegistration.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_registration_new_with_anchor_jsi(jsi::Runtime &rt, std::string voting_credential, std::string coin, std::string anchor) {
        RPtr voting_credential_mapped = stringToRptr(voting_credential);
        RPtr coin_mapped = stringToRptr(coin);
        RPtr anchor_mapped = stringToRptr(anchor);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_registration_new_with_anchor(voting_credential_mapped, coin_mapped, anchor_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepRegistration.new_with_anchor");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_update_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = drep_update_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepUpdate.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_update_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_update_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepUpdate.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_update_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = drep_update_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepUpdate.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_update_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_update_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepUpdate.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_update_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = drep_update_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepUpdate.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_update_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_update_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepUpdate.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_update_voting_credential_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_update_voting_credential(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepUpdate.voting_credential");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::drep_update_anchor_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_update_anchor(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepUpdate.anchor");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::drep_update_new_jsi(jsi::Runtime &rt, std::string voting_credential) {
        RPtr voting_credential_mapped = stringToRptr(voting_credential);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_update_new(voting_credential_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepUpdate.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_update_new_with_anchor_jsi(jsi::Runtime &rt, std::string voting_credential, std::string anchor) {
        RPtr voting_credential_mapped = stringToRptr(voting_credential);
        RPtr anchor_mapped = stringToRptr(anchor);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_update_new_with_anchor(voting_credential_mapped, anchor_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepUpdate.new_with_anchor");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::drep_update_has_script_credentials_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        drep_update_has_script_credentials(self_mapped, &ret, &err);
        throw_if_error(rt, err, "DrepUpdate.has_script_credentials");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = drep_voting_thresholds_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_voting_thresholds_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = drep_voting_thresholds_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_voting_thresholds_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = drep_voting_thresholds_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_voting_thresholds_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_new_jsi(jsi::Runtime &rt, std::string motion_no_confidence, std::string committee_normal, std::string committee_no_confidence, std::string update_constitution, std::string hard_fork_initiation, std::string pp_network_group, std::string pp_economic_group, std::string pp_technical_group, std::string pp_governance_group, std::string treasury_withdrawal) {
        RPtr motion_no_confidence_mapped = stringToRptr(motion_no_confidence);
        RPtr committee_normal_mapped = stringToRptr(committee_normal);
        RPtr committee_no_confidence_mapped = stringToRptr(committee_no_confidence);
        RPtr update_constitution_mapped = stringToRptr(update_constitution);
        RPtr hard_fork_initiation_mapped = stringToRptr(hard_fork_initiation);
        RPtr pp_network_group_mapped = stringToRptr(pp_network_group);
        RPtr pp_economic_group_mapped = stringToRptr(pp_economic_group);
        RPtr pp_technical_group_mapped = stringToRptr(pp_technical_group);
        RPtr pp_governance_group_mapped = stringToRptr(pp_governance_group);
        RPtr treasury_withdrawal_mapped = stringToRptr(treasury_withdrawal);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_voting_thresholds_new(motion_no_confidence_mapped, committee_normal_mapped, committee_no_confidence_mapped, update_constitution_mapped, hard_fork_initiation_mapped, pp_network_group_mapped, pp_economic_group_mapped, pp_technical_group_mapped, pp_governance_group_mapped, treasury_withdrawal_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_new_default_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_voting_thresholds_new_default(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.new_default");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::drep_voting_thresholds_set_motion_no_confidence_jsi(jsi::Runtime &rt, std::string self, std::string motion_no_confidence) {
        RPtr self_mapped = stringToRptr(self);
        RPtr motion_no_confidence_mapped = stringToRptr(motion_no_confidence);
        CharPtr err = nullptr;
        drep_voting_thresholds_set_motion_no_confidence(self_mapped, motion_no_confidence_mapped, &err);
        throw_if_error(rt, err, "DrepVotingThresholds.set_motion_no_confidence");
    }

    void NativeCslMobileBridgeModule::drep_voting_thresholds_set_committee_normal_jsi(jsi::Runtime &rt, std::string self, std::string committee_normal) {
        RPtr self_mapped = stringToRptr(self);
        RPtr committee_normal_mapped = stringToRptr(committee_normal);
        CharPtr err = nullptr;
        drep_voting_thresholds_set_committee_normal(self_mapped, committee_normal_mapped, &err);
        throw_if_error(rt, err, "DrepVotingThresholds.set_committee_normal");
    }

    void NativeCslMobileBridgeModule::drep_voting_thresholds_set_committee_no_confidence_jsi(jsi::Runtime &rt, std::string self, std::string committee_no_confidence) {
        RPtr self_mapped = stringToRptr(self);
        RPtr committee_no_confidence_mapped = stringToRptr(committee_no_confidence);
        CharPtr err = nullptr;
        drep_voting_thresholds_set_committee_no_confidence(self_mapped, committee_no_confidence_mapped, &err);
        throw_if_error(rt, err, "DrepVotingThresholds.set_committee_no_confidence");
    }

    void NativeCslMobileBridgeModule::drep_voting_thresholds_set_update_constitution_jsi(jsi::Runtime &rt, std::string self, std::string update_constitution) {
        RPtr self_mapped = stringToRptr(self);
        RPtr update_constitution_mapped = stringToRptr(update_constitution);
        CharPtr err = nullptr;
        drep_voting_thresholds_set_update_constitution(self_mapped, update_constitution_mapped, &err);
        throw_if_error(rt, err, "DrepVotingThresholds.set_update_constitution");
    }

    void NativeCslMobileBridgeModule::drep_voting_thresholds_set_hard_fork_initiation_jsi(jsi::Runtime &rt, std::string self, std::string hard_fork_initiation) {
        RPtr self_mapped = stringToRptr(self);
        RPtr hard_fork_initiation_mapped = stringToRptr(hard_fork_initiation);
        CharPtr err = nullptr;
        drep_voting_thresholds_set_hard_fork_initiation(self_mapped, hard_fork_initiation_mapped, &err);
        throw_if_error(rt, err, "DrepVotingThresholds.set_hard_fork_initiation");
    }

    void NativeCslMobileBridgeModule::drep_voting_thresholds_set_pp_network_group_jsi(jsi::Runtime &rt, std::string self, std::string pp_network_group) {
        RPtr self_mapped = stringToRptr(self);
        RPtr pp_network_group_mapped = stringToRptr(pp_network_group);
        CharPtr err = nullptr;
        drep_voting_thresholds_set_pp_network_group(self_mapped, pp_network_group_mapped, &err);
        throw_if_error(rt, err, "DrepVotingThresholds.set_pp_network_group");
    }

    void NativeCslMobileBridgeModule::drep_voting_thresholds_set_pp_economic_group_jsi(jsi::Runtime &rt, std::string self, std::string pp_economic_group) {
        RPtr self_mapped = stringToRptr(self);
        RPtr pp_economic_group_mapped = stringToRptr(pp_economic_group);
        CharPtr err = nullptr;
        drep_voting_thresholds_set_pp_economic_group(self_mapped, pp_economic_group_mapped, &err);
        throw_if_error(rt, err, "DrepVotingThresholds.set_pp_economic_group");
    }

    void NativeCslMobileBridgeModule::drep_voting_thresholds_set_pp_technical_group_jsi(jsi::Runtime &rt, std::string self, std::string pp_technical_group) {
        RPtr self_mapped = stringToRptr(self);
        RPtr pp_technical_group_mapped = stringToRptr(pp_technical_group);
        CharPtr err = nullptr;
        drep_voting_thresholds_set_pp_technical_group(self_mapped, pp_technical_group_mapped, &err);
        throw_if_error(rt, err, "DrepVotingThresholds.set_pp_technical_group");
    }

    void NativeCslMobileBridgeModule::drep_voting_thresholds_set_pp_governance_group_jsi(jsi::Runtime &rt, std::string self, std::string pp_governance_group) {
        RPtr self_mapped = stringToRptr(self);
        RPtr pp_governance_group_mapped = stringToRptr(pp_governance_group);
        CharPtr err = nullptr;
        drep_voting_thresholds_set_pp_governance_group(self_mapped, pp_governance_group_mapped, &err);
        throw_if_error(rt, err, "DrepVotingThresholds.set_pp_governance_group");
    }

    void NativeCslMobileBridgeModule::drep_voting_thresholds_set_treasury_withdrawal_jsi(jsi::Runtime &rt, std::string self, std::string treasury_withdrawal) {
        RPtr self_mapped = stringToRptr(self);
        RPtr treasury_withdrawal_mapped = stringToRptr(treasury_withdrawal);
        CharPtr err = nullptr;
        drep_voting_thresholds_set_treasury_withdrawal(self_mapped, treasury_withdrawal_mapped, &err);
        throw_if_error(rt, err, "DrepVotingThresholds.set_treasury_withdrawal");
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_motion_no_confidence_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_voting_thresholds_motion_no_confidence(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.motion_no_confidence");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_committee_normal_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_voting_thresholds_committee_normal(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.committee_normal");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_committee_no_confidence_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_voting_thresholds_committee_no_confidence(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.committee_no_confidence");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_update_constitution_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_voting_thresholds_update_constitution(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.update_constitution");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_hard_fork_initiation_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_voting_thresholds_hard_fork_initiation(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.hard_fork_initiation");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_pp_network_group_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_voting_thresholds_pp_network_group(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.pp_network_group");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_pp_economic_group_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_voting_thresholds_pp_economic_group(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.pp_economic_group");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_pp_technical_group_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_voting_thresholds_pp_technical_group(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.pp_technical_group");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_pp_governance_group_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_voting_thresholds_pp_governance_group(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.pp_governance_group");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::drep_voting_thresholds_treasury_withdrawal_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = drep_voting_thresholds_treasury_withdrawal(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "DrepVotingThresholds.treasury_withdrawal");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_key_hash_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ed25519_key_hash_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519KeyHash.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_key_hash_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = ed25519_key_hash_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519KeyHash.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_key_hash_to_bech32_jsi(jsi::Runtime &rt, std::string self, std::string prefix) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr prefix_mapped = stringToCharPtr(prefix);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = ed25519_key_hash_to_bech32(self_mapped, prefix_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519KeyHash.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_key_hash_from_bech32_jsi(jsi::Runtime &rt, std::string bech_str) {
        CharPtr bech_str_mapped = stringToCharPtr(bech_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ed25519_key_hash_from_bech32(bech_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519KeyHash.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_key_hash_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = ed25519_key_hash_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519KeyHash.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_key_hash_from_hex_jsi(jsi::Runtime &rt, std::string hex) {
        CharPtr hex_mapped = stringToCharPtr(hex);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ed25519_key_hash_from_hex(hex_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519KeyHash.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_key_hashes_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = ed25519_key_hashes_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519KeyHashes.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_key_hashes_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ed25519_key_hashes_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519KeyHashes.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_key_hashes_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = ed25519_key_hashes_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519KeyHashes.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_key_hashes_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ed25519_key_hashes_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519KeyHashes.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_key_hashes_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = ed25519_key_hashes_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519KeyHashes.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_key_hashes_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ed25519_key_hashes_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519KeyHashes.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_key_hashes_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ed25519_key_hashes_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519KeyHashes.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::ed25519_key_hashes_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        ed25519_key_hashes_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Ed25519KeyHashes.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_key_hashes_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ed25519_key_hashes_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519KeyHashes.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::ed25519_key_hashes_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        ed25519_key_hashes_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "Ed25519KeyHashes.add");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::ed25519_key_hashes_to_option_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ed25519_key_hashes_to_option(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519KeyHashes.to_option");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::ed25519_signature_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = ed25519_signature_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519Signature.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_signature_to_bech32_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = ed25519_signature_to_bech32(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519Signature.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_signature_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = ed25519_signature_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519Signature.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_signature_from_bech32_jsi(jsi::Runtime &rt, std::string bech32_str) {
        CharPtr bech32_str_mapped = stringToCharPtr(bech32_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ed25519_signature_from_bech32(bech32_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519Signature.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_signature_from_hex_jsi(jsi::Runtime &rt, std::string input) {
        CharPtr input_mapped = stringToCharPtr(input);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ed25519_signature_from_hex(input_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519Signature.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ed25519_signature_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ed25519_signature_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ed25519Signature.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::enterprise_address_new_jsi(jsi::Runtime &rt, double network, std::string payment) {
        int64_t network_mapped = static_cast<int64_t>(network);
        RPtr payment_mapped = stringToRptr(payment);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = enterprise_address_new(network_mapped, payment_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "EnterpriseAddress.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::enterprise_address_payment_cred_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = enterprise_address_payment_cred(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "EnterpriseAddress.payment_cred");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::enterprise_address_to_address_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = enterprise_address_to_address(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "EnterpriseAddress.to_address");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::enterprise_address_from_address_jsi(jsi::Runtime &rt, std::string addr) {
        RPtr addr_mapped = stringToRptr(addr);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = enterprise_address_from_address(addr_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "EnterpriseAddress.from_address");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::ex_unit_prices_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = ex_unit_prices_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnitPrices.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_unit_prices_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ex_unit_prices_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnitPrices.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_unit_prices_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = ex_unit_prices_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnitPrices.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_unit_prices_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ex_unit_prices_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnitPrices.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_unit_prices_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = ex_unit_prices_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnitPrices.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_unit_prices_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ex_unit_prices_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnitPrices.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_unit_prices_mem_price_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ex_unit_prices_mem_price(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnitPrices.mem_price");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_unit_prices_step_price_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ex_unit_prices_step_price(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnitPrices.step_price");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_unit_prices_new_jsi(jsi::Runtime &rt, std::string mem_price, std::string step_price) {
        RPtr mem_price_mapped = stringToRptr(mem_price);
        RPtr step_price_mapped = stringToRptr(step_price);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ex_unit_prices_new(mem_price_mapped, step_price_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnitPrices.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_units_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = ex_units_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnits.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_units_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ex_units_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnits.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_units_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = ex_units_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnits.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_units_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ex_units_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnits.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_units_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = ex_units_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnits.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_units_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ex_units_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnits.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_units_mem_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ex_units_mem(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnits.mem");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_units_steps_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ex_units_steps(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnits.steps");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ex_units_new_jsi(jsi::Runtime &rt, std::string mem, std::string steps) {
        RPtr mem_mapped = stringToRptr(mem);
        RPtr steps_mapped = stringToRptr(steps);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ex_units_new(mem_mapped, steps_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ExUnits.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::fixed_transaction_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = fixed_transaction_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "FixedTransaction.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::fixed_transaction_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = fixed_transaction_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "FixedTransaction.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::fixed_transaction_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = fixed_transaction_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "FixedTransaction.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::fixed_transaction_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = fixed_transaction_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "FixedTransaction.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::fixed_transaction_new_jsi(jsi::Runtime &rt, std::string raw_body, std::string raw_witness_set, bool is_valid) {
        auto raw_body_mapped = base64ToBytes(raw_body);
        auto raw_witness_set_mapped = base64ToBytes(raw_witness_set);
        bool is_valid_mapped = static_cast<bool>(is_valid);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = fixed_transaction_new(raw_body_mapped.data(), raw_body_mapped.size(), raw_witness_set_mapped.data(), raw_witness_set_mapped.size(), is_valid_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "FixedTransaction.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::fixed_transaction_new_with_auxiliary_jsi(jsi::Runtime &rt, std::string raw_body, std::string raw_witness_set, std::string raw_auxiliary_data, bool is_valid) {
        auto raw_body_mapped = base64ToBytes(raw_body);
        auto raw_witness_set_mapped = base64ToBytes(raw_witness_set);
        auto raw_auxiliary_data_mapped = base64ToBytes(raw_auxiliary_data);
        bool is_valid_mapped = static_cast<bool>(is_valid);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = fixed_transaction_new_with_auxiliary(raw_body_mapped.data(), raw_body_mapped.size(), raw_witness_set_mapped.data(), raw_witness_set_mapped.size(), raw_auxiliary_data_mapped.data(), raw_auxiliary_data_mapped.size(), is_valid_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "FixedTransaction.new_with_auxiliary");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::fixed_transaction_body_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = fixed_transaction_body(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "FixedTransaction.body");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::fixed_transaction_raw_body_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = fixed_transaction_raw_body(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "FixedTransaction.raw_body");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::fixed_transaction_set_body_jsi(jsi::Runtime &rt, std::string self, std::string raw_body) {
        RPtr self_mapped = stringToRptr(self);
        auto raw_body_mapped = base64ToBytes(raw_body);
        CharPtr err = nullptr;
        fixed_transaction_set_body(self_mapped, raw_body_mapped.data(), raw_body_mapped.size(), &err);
        throw_if_error(rt, err, "FixedTransaction.set_body");
    }

    void NativeCslMobileBridgeModule::fixed_transaction_set_witness_set_jsi(jsi::Runtime &rt, std::string self, std::string raw_witness_set) {
        RPtr self_mapped = stringToRptr(self);
        auto raw_witness_set_mapped = base64ToBytes(raw_witness_set);
        CharPtr err = nullptr;
        fixed_transaction_set_witness_set(self_mapped, raw_witness_set_mapped.data(), raw_witness_set_mapped.size(), &err);
        throw_if_error(rt, err, "FixedTransaction.set_witness_set");
    }

    std::string NativeCslMobileBridgeModule::fixed_transaction_witness_set_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = fixed_transaction_witness_set(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "FixedTransaction.witness_set");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::fixed_transaction_raw_witness_set_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = fixed_transaction_raw_witness_set(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "FixedTransaction.raw_witness_set");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::fixed_transaction_set_is_valid_jsi(jsi::Runtime &rt, std::string self, bool valid) {
        RPtr self_mapped = stringToRptr(self);
        bool valid_mapped = static_cast<bool>(valid);
        CharPtr err = nullptr;
        fixed_transaction_set_is_valid(self_mapped, valid_mapped, &err);
        throw_if_error(rt, err, "FixedTransaction.set_is_valid");
    }

    bool NativeCslMobileBridgeModule::fixed_transaction_is_valid_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        fixed_transaction_is_valid(self_mapped, &ret, &err);
        throw_if_error(rt, err, "FixedTransaction.is_valid");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::fixed_transaction_set_auxiliary_data_jsi(jsi::Runtime &rt, std::string self, std::string raw_auxiliary_data) {
        RPtr self_mapped = stringToRptr(self);
        auto raw_auxiliary_data_mapped = base64ToBytes(raw_auxiliary_data);
        CharPtr err = nullptr;
        fixed_transaction_set_auxiliary_data(self_mapped, raw_auxiliary_data_mapped.data(), raw_auxiliary_data_mapped.size(), &err);
        throw_if_error(rt, err, "FixedTransaction.set_auxiliary_data");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::fixed_transaction_auxiliary_data_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = fixed_transaction_auxiliary_data(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "FixedTransaction.auxiliary_data");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::fixed_transaction_raw_auxiliary_data_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = fixed_transaction_raw_auxiliary_data(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "FixedTransaction.raw_auxiliary_data");
        }
        if(has_ret) {
            auto mapped_ret = dataPtrToBase64(&ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::general_transaction_metadata_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = general_transaction_metadata_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "GeneralTransactionMetadata.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::general_transaction_metadata_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = general_transaction_metadata_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GeneralTransactionMetadata.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::general_transaction_metadata_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = general_transaction_metadata_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "GeneralTransactionMetadata.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::general_transaction_metadata_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = general_transaction_metadata_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GeneralTransactionMetadata.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::general_transaction_metadata_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = general_transaction_metadata_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "GeneralTransactionMetadata.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::general_transaction_metadata_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = general_transaction_metadata_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GeneralTransactionMetadata.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::general_transaction_metadata_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = general_transaction_metadata_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GeneralTransactionMetadata.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::general_transaction_metadata_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        general_transaction_metadata_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "GeneralTransactionMetadata.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::general_transaction_metadata_insert_jsi(jsi::Runtime &rt, std::string self, std::string key, std::string value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        RPtr value_mapped = stringToRptr(value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = general_transaction_metadata_insert(self_mapped, key_mapped, value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GeneralTransactionMetadata.insert");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::general_transaction_metadata_get_jsi(jsi::Runtime &rt, std::string self, std::string key) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = general_transaction_metadata_get(self_mapped, key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GeneralTransactionMetadata.get");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::general_transaction_metadata_keys_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = general_transaction_metadata_keys(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GeneralTransactionMetadata.keys");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_delegate_hash_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_delegate_hash_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisDelegateHash.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_delegate_hash_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = genesis_delegate_hash_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisDelegateHash.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_delegate_hash_to_bech32_jsi(jsi::Runtime &rt, std::string self, std::string prefix) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr prefix_mapped = stringToCharPtr(prefix);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = genesis_delegate_hash_to_bech32(self_mapped, prefix_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisDelegateHash.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_delegate_hash_from_bech32_jsi(jsi::Runtime &rt, std::string bech_str) {
        CharPtr bech_str_mapped = stringToCharPtr(bech_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_delegate_hash_from_bech32(bech_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisDelegateHash.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_delegate_hash_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = genesis_delegate_hash_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisDelegateHash.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_delegate_hash_from_hex_jsi(jsi::Runtime &rt, std::string hex) {
        CharPtr hex_mapped = stringToCharPtr(hex);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_delegate_hash_from_hex(hex_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisDelegateHash.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_hash_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_hash_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisHash.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_hash_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = genesis_hash_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisHash.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_hash_to_bech32_jsi(jsi::Runtime &rt, std::string self, std::string prefix) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr prefix_mapped = stringToCharPtr(prefix);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = genesis_hash_to_bech32(self_mapped, prefix_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisHash.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_hash_from_bech32_jsi(jsi::Runtime &rt, std::string bech_str) {
        CharPtr bech_str_mapped = stringToCharPtr(bech_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_hash_from_bech32(bech_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisHash.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_hash_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = genesis_hash_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisHash.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_hash_from_hex_jsi(jsi::Runtime &rt, std::string hex) {
        CharPtr hex_mapped = stringToCharPtr(hex);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_hash_from_hex(hex_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisHash.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_hashes_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = genesis_hashes_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisHashes.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_hashes_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_hashes_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisHashes.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_hashes_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = genesis_hashes_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisHashes.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_hashes_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_hashes_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisHashes.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_hashes_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = genesis_hashes_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisHashes.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_hashes_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_hashes_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisHashes.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_hashes_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_hashes_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisHashes.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::genesis_hashes_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        genesis_hashes_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "GenesisHashes.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_hashes_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_hashes_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisHashes.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::genesis_hashes_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        genesis_hashes_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "GenesisHashes.add");
    }

    std::string NativeCslMobileBridgeModule::genesis_key_delegation_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = genesis_key_delegation_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisKeyDelegation.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_key_delegation_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_key_delegation_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisKeyDelegation.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_key_delegation_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = genesis_key_delegation_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisKeyDelegation.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_key_delegation_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_key_delegation_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisKeyDelegation.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_key_delegation_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = genesis_key_delegation_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisKeyDelegation.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_key_delegation_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_key_delegation_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisKeyDelegation.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_key_delegation_genesishash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_key_delegation_genesishash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisKeyDelegation.genesishash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_key_delegation_genesis_delegate_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_key_delegation_genesis_delegate_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisKeyDelegation.genesis_delegate_hash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_key_delegation_vrf_keyhash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_key_delegation_vrf_keyhash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisKeyDelegation.vrf_keyhash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::genesis_key_delegation_new_jsi(jsi::Runtime &rt, std::string genesishash, std::string genesis_delegate_hash, std::string vrf_keyhash) {
        RPtr genesishash_mapped = stringToRptr(genesishash);
        RPtr genesis_delegate_hash_mapped = stringToRptr(genesis_delegate_hash);
        RPtr vrf_keyhash_mapped = stringToRptr(vrf_keyhash);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = genesis_key_delegation_new(genesishash_mapped, genesis_delegate_hash_mapped, vrf_keyhash_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GenesisKeyDelegation.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = governance_action_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = governance_action_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = governance_action_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_new_parameter_change_action_jsi(jsi::Runtime &rt, std::string parameter_change_action) {
        RPtr parameter_change_action_mapped = stringToRptr(parameter_change_action);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_new_parameter_change_action(parameter_change_action_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.new_parameter_change_action");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_new_hard_fork_initiation_action_jsi(jsi::Runtime &rt, std::string hard_fork_initiation_action) {
        RPtr hard_fork_initiation_action_mapped = stringToRptr(hard_fork_initiation_action);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_new_hard_fork_initiation_action(hard_fork_initiation_action_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.new_hard_fork_initiation_action");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_new_treasury_withdrawals_action_jsi(jsi::Runtime &rt, std::string treasury_withdrawals_action) {
        RPtr treasury_withdrawals_action_mapped = stringToRptr(treasury_withdrawals_action);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_new_treasury_withdrawals_action(treasury_withdrawals_action_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.new_treasury_withdrawals_action");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_new_no_confidence_action_jsi(jsi::Runtime &rt, std::string no_confidence_action) {
        RPtr no_confidence_action_mapped = stringToRptr(no_confidence_action);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_new_no_confidence_action(no_confidence_action_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.new_no_confidence_action");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_new_new_committee_action_jsi(jsi::Runtime &rt, std::string new_committee_action) {
        RPtr new_committee_action_mapped = stringToRptr(new_committee_action);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_new_new_committee_action(new_committee_action_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.new_new_committee_action");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_new_new_constitution_action_jsi(jsi::Runtime &rt, std::string new_constitution_action) {
        RPtr new_constitution_action_mapped = stringToRptr(new_constitution_action);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_new_new_constitution_action(new_constitution_action_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.new_new_constitution_action");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_new_info_action_jsi(jsi::Runtime &rt, std::string info_action) {
        RPtr info_action_mapped = stringToRptr(info_action);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_new_info_action(info_action_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.new_info_action");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::governance_action_kind_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int32_t ret;
        governance_action_kind(self_mapped, &ret, &err);
        throw_if_error(rt, err, "GovernanceAction.kind");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::governance_action_as_parameter_change_action_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_as_parameter_change_action(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.as_parameter_change_action");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::governance_action_as_hard_fork_initiation_action_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_as_hard_fork_initiation_action(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.as_hard_fork_initiation_action");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::governance_action_as_treasury_withdrawals_action_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_as_treasury_withdrawals_action(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.as_treasury_withdrawals_action");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::governance_action_as_no_confidence_action_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_as_no_confidence_action(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.as_no_confidence_action");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::governance_action_as_new_committee_action_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_as_new_committee_action(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.as_new_committee_action");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::governance_action_as_new_constitution_action_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_as_new_constitution_action(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.as_new_constitution_action");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::governance_action_as_info_action_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_as_info_action(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceAction.as_info_action");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::governance_action_id_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = governance_action_id_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceActionId.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_id_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_id_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceActionId.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_id_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = governance_action_id_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceActionId.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_id_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_id_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceActionId.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_id_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = governance_action_id_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceActionId.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_id_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_id_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceActionId.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_id_transaction_id_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_id_transaction_id(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceActionId.transaction_id");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::governance_action_id_index_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        governance_action_id_index(self_mapped, &ret, &err);
        throw_if_error(rt, err, "GovernanceActionId.index");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_id_new_jsi(jsi::Runtime &rt, std::string transaction_id, double index) {
        RPtr transaction_id_mapped = stringToRptr(transaction_id);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_id_new(transaction_id_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceActionId.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_ids_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = governance_action_ids_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceActionIds.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_ids_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_ids_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceActionIds.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::governance_action_ids_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_ids_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceActionIds.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::governance_action_ids_add_jsi(jsi::Runtime &rt, std::string self, std::string governance_action_id) {
        RPtr self_mapped = stringToRptr(self);
        RPtr governance_action_id_mapped = stringToRptr(governance_action_id);
        CharPtr err = nullptr;
        governance_action_ids_add(self_mapped, governance_action_id_mapped, &err);
        throw_if_error(rt, err, "GovernanceActionIds.add");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::governance_action_ids_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = governance_action_ids_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "GovernanceActionIds.get");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    double NativeCslMobileBridgeModule::governance_action_ids_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        governance_action_ids_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "GovernanceActionIds.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::hard_fork_initiation_action_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = hard_fork_initiation_action_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "HardForkInitiationAction.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::hard_fork_initiation_action_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = hard_fork_initiation_action_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HardForkInitiationAction.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::hard_fork_initiation_action_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = hard_fork_initiation_action_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "HardForkInitiationAction.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::hard_fork_initiation_action_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = hard_fork_initiation_action_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HardForkInitiationAction.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::hard_fork_initiation_action_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = hard_fork_initiation_action_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "HardForkInitiationAction.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::hard_fork_initiation_action_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = hard_fork_initiation_action_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HardForkInitiationAction.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::hard_fork_initiation_action_gov_action_id_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = hard_fork_initiation_action_gov_action_id(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HardForkInitiationAction.gov_action_id");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::hard_fork_initiation_action_protocol_version_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = hard_fork_initiation_action_protocol_version(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HardForkInitiationAction.protocol_version");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::hard_fork_initiation_action_new_jsi(jsi::Runtime &rt, std::string protocol_version) {
        RPtr protocol_version_mapped = stringToRptr(protocol_version);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = hard_fork_initiation_action_new(protocol_version_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HardForkInitiationAction.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::hard_fork_initiation_action_new_with_action_id_jsi(jsi::Runtime &rt, std::string gov_action_id, std::string protocol_version) {
        RPtr gov_action_id_mapped = stringToRptr(gov_action_id);
        RPtr protocol_version_mapped = stringToRptr(protocol_version);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = hard_fork_initiation_action_new_with_action_id(gov_action_id_mapped, protocol_version_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HardForkInitiationAction.new_with_action_id");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = header_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Header.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Header.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = header_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Header.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Header.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = header_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Header.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Header.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_header_body_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_header_body(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Header.header_body");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_body_signature_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_signature(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Header.body_signature");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_new_jsi(jsi::Runtime &rt, std::string header_body, std::string body_signature) {
        RPtr header_body_mapped = stringToRptr(header_body);
        RPtr body_signature_mapped = stringToRptr(body_signature);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_new(header_body_mapped, body_signature_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Header.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_body_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = header_body_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_body_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_body_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = header_body_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_body_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_body_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = header_body_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_body_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::header_body_block_number_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        header_body_block_number(self_mapped, &ret, &err);
        throw_if_error(rt, err, "HeaderBody.block_number");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::header_body_slot_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        header_body_slot(self_mapped, &ret, &err);
        throw_if_error(rt, err, "HeaderBody.slot");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_body_slot_bignum_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_slot_bignum(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.slot_bignum");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::header_body_prev_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_prev_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.prev_hash");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::header_body_issuer_vkey_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_issuer_vkey(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.issuer_vkey");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_body_vrf_vkey_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_vrf_vkey(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.vrf_vkey");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::header_body_has_nonce_and_leader_vrf_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        header_body_has_nonce_and_leader_vrf(self_mapped, &ret, &err);
        throw_if_error(rt, err, "HeaderBody.has_nonce_and_leader_vrf");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::header_body_nonce_vrf_or_nothing_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_nonce_vrf_or_nothing(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.nonce_vrf_or_nothing");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::header_body_leader_vrf_or_nothing_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_leader_vrf_or_nothing(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.leader_vrf_or_nothing");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    bool NativeCslMobileBridgeModule::header_body_has_vrf_result_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        header_body_has_vrf_result(self_mapped, &ret, &err);
        throw_if_error(rt, err, "HeaderBody.has_vrf_result");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::header_body_vrf_result_or_nothing_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_vrf_result_or_nothing(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.vrf_result_or_nothing");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    double NativeCslMobileBridgeModule::header_body_block_body_size_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        header_body_block_body_size(self_mapped, &ret, &err);
        throw_if_error(rt, err, "HeaderBody.block_body_size");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_body_block_body_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_block_body_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.block_body_hash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_body_operational_cert_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_operational_cert(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.operational_cert");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_body_protocol_version_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_protocol_version(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.protocol_version");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_body_new_jsi(jsi::Runtime &rt, double block_number, double slot, std::string issuer_vkey, std::string vrf_vkey, std::string vrf_result, double block_body_size, std::string block_body_hash, std::string operational_cert, std::string protocol_version) {
        int64_t block_number_mapped = static_cast<int64_t>(block_number);
        int64_t slot_mapped = static_cast<int64_t>(slot);
        RPtr issuer_vkey_mapped = stringToRptr(issuer_vkey);
        RPtr vrf_vkey_mapped = stringToRptr(vrf_vkey);
        RPtr vrf_result_mapped = stringToRptr(vrf_result);
        int64_t block_body_size_mapped = static_cast<int64_t>(block_body_size);
        RPtr block_body_hash_mapped = stringToRptr(block_body_hash);
        RPtr operational_cert_mapped = stringToRptr(operational_cert);
        RPtr protocol_version_mapped = stringToRptr(protocol_version);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_new(block_number_mapped, slot_mapped, issuer_vkey_mapped, vrf_vkey_mapped, vrf_result_mapped, block_body_size_mapped, block_body_hash_mapped, operational_cert_mapped, protocol_version_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_body_new_with_prev_hash_jsi(jsi::Runtime &rt, double block_number, double slot, std::string prev_hash, std::string issuer_vkey, std::string vrf_vkey, std::string vrf_result, double block_body_size, std::string block_body_hash, std::string operational_cert, std::string protocol_version) {
        int64_t block_number_mapped = static_cast<int64_t>(block_number);
        int64_t slot_mapped = static_cast<int64_t>(slot);
        RPtr prev_hash_mapped = stringToRptr(prev_hash);
        RPtr issuer_vkey_mapped = stringToRptr(issuer_vkey);
        RPtr vrf_vkey_mapped = stringToRptr(vrf_vkey);
        RPtr vrf_result_mapped = stringToRptr(vrf_result);
        int64_t block_body_size_mapped = static_cast<int64_t>(block_body_size);
        RPtr block_body_hash_mapped = stringToRptr(block_body_hash);
        RPtr operational_cert_mapped = stringToRptr(operational_cert);
        RPtr protocol_version_mapped = stringToRptr(protocol_version);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_new_with_prev_hash(block_number_mapped, slot_mapped, prev_hash_mapped, issuer_vkey_mapped, vrf_vkey_mapped, vrf_result_mapped, block_body_size_mapped, block_body_hash_mapped, operational_cert_mapped, protocol_version_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.new_with_prev_hash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_body_new_headerbody_jsi(jsi::Runtime &rt, double block_number, std::string slot, std::string issuer_vkey, std::string vrf_vkey, std::string vrf_result, double block_body_size, std::string block_body_hash, std::string operational_cert, std::string protocol_version) {
        int64_t block_number_mapped = static_cast<int64_t>(block_number);
        RPtr slot_mapped = stringToRptr(slot);
        RPtr issuer_vkey_mapped = stringToRptr(issuer_vkey);
        RPtr vrf_vkey_mapped = stringToRptr(vrf_vkey);
        RPtr vrf_result_mapped = stringToRptr(vrf_result);
        int64_t block_body_size_mapped = static_cast<int64_t>(block_body_size);
        RPtr block_body_hash_mapped = stringToRptr(block_body_hash);
        RPtr operational_cert_mapped = stringToRptr(operational_cert);
        RPtr protocol_version_mapped = stringToRptr(protocol_version);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_new_headerbody(block_number_mapped, slot_mapped, issuer_vkey_mapped, vrf_vkey_mapped, vrf_result_mapped, block_body_size_mapped, block_body_hash_mapped, operational_cert_mapped, protocol_version_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.new_headerbody");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::header_body_new_headerbody_with_prev_hash_jsi(jsi::Runtime &rt, double block_number, std::string slot, std::string prev_hash, std::string issuer_vkey, std::string vrf_vkey, std::string vrf_result, double block_body_size, std::string block_body_hash, std::string operational_cert, std::string protocol_version) {
        int64_t block_number_mapped = static_cast<int64_t>(block_number);
        RPtr slot_mapped = stringToRptr(slot);
        RPtr prev_hash_mapped = stringToRptr(prev_hash);
        RPtr issuer_vkey_mapped = stringToRptr(issuer_vkey);
        RPtr vrf_vkey_mapped = stringToRptr(vrf_vkey);
        RPtr vrf_result_mapped = stringToRptr(vrf_result);
        int64_t block_body_size_mapped = static_cast<int64_t>(block_body_size);
        RPtr block_body_hash_mapped = stringToRptr(block_body_hash);
        RPtr operational_cert_mapped = stringToRptr(operational_cert);
        RPtr protocol_version_mapped = stringToRptr(protocol_version);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = header_body_new_headerbody_with_prev_hash(block_number_mapped, slot_mapped, prev_hash_mapped, issuer_vkey_mapped, vrf_vkey_mapped, vrf_result_mapped, block_body_size_mapped, block_body_hash_mapped, operational_cert_mapped, protocol_version_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "HeaderBody.new_headerbody_with_prev_hash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::info_action_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = info_action_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "InfoAction.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::input_with_script_witness_new_with_native_script_witness_jsi(jsi::Runtime &rt, std::string input, std::string witness) {
        RPtr input_mapped = stringToRptr(input);
        RPtr witness_mapped = stringToRptr(witness);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = input_with_script_witness_new_with_native_script_witness(input_mapped, witness_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "InputWithScriptWitness.new_with_native_script_witness");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::input_with_script_witness_new_with_plutus_witness_jsi(jsi::Runtime &rt, std::string input, std::string witness) {
        RPtr input_mapped = stringToRptr(input);
        RPtr witness_mapped = stringToRptr(witness);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = input_with_script_witness_new_with_plutus_witness(input_mapped, witness_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "InputWithScriptWitness.new_with_plutus_witness");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::input_with_script_witness_input_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = input_with_script_witness_input(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "InputWithScriptWitness.input");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::inputs_with_script_witness_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = inputs_with_script_witness_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "InputsWithScriptWitness.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::inputs_with_script_witness_add_jsi(jsi::Runtime &rt, std::string self, std::string input) {
        RPtr self_mapped = stringToRptr(self);
        RPtr input_mapped = stringToRptr(input);
        CharPtr err = nullptr;
        inputs_with_script_witness_add(self_mapped, input_mapped, &err);
        throw_if_error(rt, err, "InputsWithScriptWitness.add");
    }

    std::string NativeCslMobileBridgeModule::inputs_with_script_witness_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = inputs_with_script_witness_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "InputsWithScriptWitness.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::inputs_with_script_witness_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        inputs_with_script_witness_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "InputsWithScriptWitness.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::int_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = int_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Int.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::int_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = int_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Int.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::int_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = int_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Int.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::int_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = int_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Int.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::int_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = int_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Int.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::int_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = int_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Int.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::int_new_jsi(jsi::Runtime &rt, std::string x) {
        RPtr x_mapped = stringToRptr(x);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = int_new(x_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Int.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::int_new_negative_jsi(jsi::Runtime &rt, std::string x) {
        RPtr x_mapped = stringToRptr(x);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = int_new_negative(x_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Int.new_negative");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::int_new_i32_jsi(jsi::Runtime &rt, double x) {
        int64_t x_mapped = static_cast<int64_t>(x);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = int_new_i32(x_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Int.new_i32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::int_is_positive_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        int_is_positive(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Int.is_positive");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::int_as_positive_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = int_as_positive(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Int.as_positive");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::int_as_negative_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = int_as_negative(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Int.as_negative");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<double> NativeCslMobileBridgeModule::int_as_i32_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = int_as_i32(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Int.as_i32");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<double> NativeCslMobileBridgeModule::int_as_i32_or_nothing_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = int_as_i32_or_nothing(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Int.as_i32_or_nothing");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    double NativeCslMobileBridgeModule::int_as_i32_or_fail_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        int_as_i32_or_fail(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Int.as_i32_or_fail");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::int_to_str_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = int_to_str(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Int.to_str");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::int_from_str_jsi(jsi::Runtime &rt, std::string string) {
        CharPtr string_mapped = stringToCharPtr(string);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = int_from_str(string_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Int.from_str");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ipv4_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = ipv4_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Ipv4.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ipv4_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ipv4_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ipv4.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ipv4_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = ipv4_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Ipv4.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ipv4_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ipv4_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ipv4.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ipv4_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = ipv4_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Ipv4.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ipv4_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ipv4_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ipv4.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ipv4_new_jsi(jsi::Runtime &rt, std::string data) {
        auto data_mapped = base64ToBytes(data);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ipv4_new(data_mapped.data(), data_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ipv4.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ipv4_ip_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = ipv4_ip(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Ipv4.ip");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ipv6_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = ipv6_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Ipv6.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ipv6_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ipv6_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ipv6.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ipv6_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = ipv6_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Ipv6.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ipv6_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ipv6_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ipv6.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ipv6_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = ipv6_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Ipv6.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ipv6_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ipv6_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ipv6.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ipv6_new_jsi(jsi::Runtime &rt, std::string data) {
        auto data_mapped = base64ToBytes(data);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = ipv6_new(data_mapped.data(), data_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Ipv6.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::ipv6_ip_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = ipv6_ip(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Ipv6.ip");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::k_e_s_signature_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = k_e_s_signature_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "KESSignature.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::k_e_s_signature_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = k_e_s_signature_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "KESSignature.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::k_e_s_v_key_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = k_e_s_v_key_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "KESVKey.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::k_e_s_v_key_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = k_e_s_v_key_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "KESVKey.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::k_e_s_v_key_to_bech32_jsi(jsi::Runtime &rt, std::string self, std::string prefix) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr prefix_mapped = stringToCharPtr(prefix);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = k_e_s_v_key_to_bech32(self_mapped, prefix_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "KESVKey.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::k_e_s_v_key_from_bech32_jsi(jsi::Runtime &rt, std::string bech_str) {
        CharPtr bech_str_mapped = stringToCharPtr(bech_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = k_e_s_v_key_from_bech32(bech_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "KESVKey.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::k_e_s_v_key_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = k_e_s_v_key_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "KESVKey.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::k_e_s_v_key_from_hex_jsi(jsi::Runtime &rt, std::string hex) {
        CharPtr hex_mapped = stringToCharPtr(hex);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = k_e_s_v_key_from_hex(hex_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "KESVKey.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::language_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = language_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Language.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::language_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = language_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Language.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::language_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = language_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Language.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::language_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = language_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Language.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::language_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = language_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Language.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::language_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = language_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Language.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::language_new_plutus_v1_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = language_new_plutus_v1(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Language.new_plutus_v1");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::language_new_plutus_v2_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = language_new_plutus_v2(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Language.new_plutus_v2");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::language_new_plutus_v3_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = language_new_plutus_v3(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Language.new_plutus_v3");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::language_kind_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int32_t ret;
        language_kind(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Language.kind");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::languages_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = languages_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Languages.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::languages_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        languages_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Languages.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::languages_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = languages_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Languages.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::languages_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        languages_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "Languages.add");
    }

    std::string NativeCslMobileBridgeModule::languages_list_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = languages_list(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Languages.list");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::legacy_daedalus_private_key_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = legacy_daedalus_private_key_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "LegacyDaedalusPrivateKey.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::legacy_daedalus_private_key_as_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = legacy_daedalus_private_key_as_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "LegacyDaedalusPrivateKey.as_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::legacy_daedalus_private_key_chaincode_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = legacy_daedalus_private_key_chaincode(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "LegacyDaedalusPrivateKey.chaincode");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::linear_fee_constant_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = linear_fee_constant(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "LinearFee.constant");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::linear_fee_coefficient_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = linear_fee_coefficient(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "LinearFee.coefficient");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::linear_fee_new_jsi(jsi::Runtime &rt, std::string coefficient, std::string constant) {
        RPtr coefficient_mapped = stringToRptr(coefficient);
        RPtr constant_mapped = stringToRptr(constant);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = linear_fee_new(coefficient_mapped, constant_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "LinearFee.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::m_i_r_to_stake_credentials_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = m_i_r_to_stake_credentials_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "MIRToStakeCredentials.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::m_i_r_to_stake_credentials_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = m_i_r_to_stake_credentials_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MIRToStakeCredentials.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::m_i_r_to_stake_credentials_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = m_i_r_to_stake_credentials_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "MIRToStakeCredentials.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::m_i_r_to_stake_credentials_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = m_i_r_to_stake_credentials_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MIRToStakeCredentials.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::m_i_r_to_stake_credentials_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = m_i_r_to_stake_credentials_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "MIRToStakeCredentials.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::m_i_r_to_stake_credentials_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = m_i_r_to_stake_credentials_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MIRToStakeCredentials.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::m_i_r_to_stake_credentials_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = m_i_r_to_stake_credentials_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MIRToStakeCredentials.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::m_i_r_to_stake_credentials_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        m_i_r_to_stake_credentials_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "MIRToStakeCredentials.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::m_i_r_to_stake_credentials_insert_jsi(jsi::Runtime &rt, std::string self, std::string cred, std::string delta) {
        RPtr self_mapped = stringToRptr(self);
        RPtr cred_mapped = stringToRptr(cred);
        RPtr delta_mapped = stringToRptr(delta);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = m_i_r_to_stake_credentials_insert(self_mapped, cred_mapped, delta_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MIRToStakeCredentials.insert");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::m_i_r_to_stake_credentials_get_jsi(jsi::Runtime &rt, std::string self, std::string cred) {
        RPtr self_mapped = stringToRptr(self);
        RPtr cred_mapped = stringToRptr(cred);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = m_i_r_to_stake_credentials_get(self_mapped, cred_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MIRToStakeCredentials.get");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::m_i_r_to_stake_credentials_keys_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = m_i_r_to_stake_credentials_keys(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MIRToStakeCredentials.keys");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::metadata_list_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = metadata_list_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataList.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::metadata_list_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = metadata_list_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataList.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::metadata_list_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = metadata_list_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataList.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::metadata_list_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = metadata_list_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataList.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::metadata_list_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = metadata_list_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataList.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::metadata_list_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        metadata_list_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "MetadataList.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::metadata_list_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = metadata_list_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataList.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::metadata_list_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        metadata_list_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "MetadataList.add");
    }

    std::string NativeCslMobileBridgeModule::metadata_map_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = metadata_map_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataMap.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::metadata_map_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = metadata_map_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataMap.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::metadata_map_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = metadata_map_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataMap.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::metadata_map_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = metadata_map_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataMap.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::metadata_map_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = metadata_map_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataMap.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::metadata_map_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        metadata_map_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "MetadataMap.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::metadata_map_insert_jsi(jsi::Runtime &rt, std::string self, std::string key, std::string value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        RPtr value_mapped = stringToRptr(value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = metadata_map_insert(self_mapped, key_mapped, value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataMap.insert");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::metadata_map_insert_str_jsi(jsi::Runtime &rt, std::string self, std::string key, std::string value) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr key_mapped = stringToCharPtr(key);
        RPtr value_mapped = stringToRptr(value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = metadata_map_insert_str(self_mapped, key_mapped, value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataMap.insert_str");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::metadata_map_insert_i32_jsi(jsi::Runtime &rt, std::string self, double key, std::string value) {
        RPtr self_mapped = stringToRptr(self);
        int64_t key_mapped = static_cast<int64_t>(key);
        RPtr value_mapped = stringToRptr(value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = metadata_map_insert_i32(self_mapped, key_mapped, value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataMap.insert_i32");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::metadata_map_get_jsi(jsi::Runtime &rt, std::string self, std::string key) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = metadata_map_get(self_mapped, key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataMap.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::metadata_map_get_str_jsi(jsi::Runtime &rt, std::string self, std::string key) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr key_mapped = stringToCharPtr(key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = metadata_map_get_str(self_mapped, key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataMap.get_str");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::metadata_map_get_i32_jsi(jsi::Runtime &rt, std::string self, double key) {
        RPtr self_mapped = stringToRptr(self);
        int64_t key_mapped = static_cast<int64_t>(key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = metadata_map_get_i32(self_mapped, key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataMap.get_i32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::metadata_map_has_jsi(jsi::Runtime &rt, std::string self, std::string key) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        bool ret;
        metadata_map_has(self_mapped, key_mapped, &ret, &err);
        throw_if_error(rt, err, "MetadataMap.has");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::metadata_map_keys_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = metadata_map_keys(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MetadataMap.keys");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = mint_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Mint.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Mint.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = mint_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Mint.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Mint.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = mint_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Mint.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Mint.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Mint.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_new_from_entry_jsi(jsi::Runtime &rt, std::string key, std::string value) {
        RPtr key_mapped = stringToRptr(key);
        RPtr value_mapped = stringToRptr(value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_new_from_entry(key_mapped, value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Mint.new_from_entry");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::mint_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        mint_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Mint.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::mint_insert_jsi(jsi::Runtime &rt, std::string self, std::string key, std::string value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        RPtr value_mapped = stringToRptr(value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_insert(self_mapped, key_mapped, value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Mint.insert");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::mint_get_jsi(jsi::Runtime &rt, std::string self, std::string key) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_get(self_mapped, key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Mint.get");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::mint_get_all_jsi(jsi::Runtime &rt, std::string self, std::string key) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_get_all(self_mapped, key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Mint.get_all");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::mint_keys_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_keys(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Mint.keys");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_as_positive_multiasset_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_as_positive_multiasset(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Mint.as_positive_multiasset");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_as_negative_multiasset_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_as_negative_multiasset(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Mint.as_negative_multiasset");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_assets_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_assets_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MintAssets.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_assets_new_from_entry_jsi(jsi::Runtime &rt, std::string key, std::string value) {
        RPtr key_mapped = stringToRptr(key);
        RPtr value_mapped = stringToRptr(value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_assets_new_from_entry(key_mapped, value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MintAssets.new_from_entry");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::mint_assets_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        mint_assets_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "MintAssets.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::mint_assets_insert_jsi(jsi::Runtime &rt, std::string self, std::string key, std::string value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        RPtr value_mapped = stringToRptr(value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_assets_insert(self_mapped, key_mapped, value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MintAssets.insert");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::mint_assets_get_jsi(jsi::Runtime &rt, std::string self, std::string key) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_assets_get(self_mapped, key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MintAssets.get");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::mint_assets_keys_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_assets_keys(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MintAssets.keys");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_builder_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_builder_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MintBuilder.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::mint_builder_add_asset_jsi(jsi::Runtime &rt, std::string self, std::string mint, std::string asset_name, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr mint_mapped = stringToRptr(mint);
        RPtr asset_name_mapped = stringToRptr(asset_name);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        mint_builder_add_asset(self_mapped, mint_mapped, asset_name_mapped, amount_mapped, &err);
        throw_if_error(rt, err, "MintBuilder.add_asset");
    }

    void NativeCslMobileBridgeModule::mint_builder_set_asset_jsi(jsi::Runtime &rt, std::string self, std::string mint, std::string asset_name, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr mint_mapped = stringToRptr(mint);
        RPtr asset_name_mapped = stringToRptr(asset_name);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        mint_builder_set_asset(self_mapped, mint_mapped, asset_name_mapped, amount_mapped, &err);
        throw_if_error(rt, err, "MintBuilder.set_asset");
    }

    std::string NativeCslMobileBridgeModule::mint_builder_build_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_builder_build(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MintBuilder.build");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_builder_get_native_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_builder_get_native_scripts(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MintBuilder.get_native_scripts");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_builder_get_plutus_witnesses_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_builder_get_plutus_witnesses(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MintBuilder.get_plutus_witnesses");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_builder_get_ref_inputs_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_builder_get_ref_inputs(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MintBuilder.get_ref_inputs");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_builder_get_redeeemers_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_builder_get_redeeemers(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MintBuilder.get_redeeemers");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::mint_builder_has_plutus_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        mint_builder_has_plutus_scripts(self_mapped, &ret, &err);
        throw_if_error(rt, err, "MintBuilder.has_plutus_scripts");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::mint_builder_has_native_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        mint_builder_has_native_scripts(self_mapped, &ret, &err);
        throw_if_error(rt, err, "MintBuilder.has_native_scripts");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_witness_new_native_script_jsi(jsi::Runtime &rt, std::string native_script) {
        RPtr native_script_mapped = stringToRptr(native_script);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_witness_new_native_script(native_script_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MintWitness.new_native_script");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::mint_witness_new_plutus_script_jsi(jsi::Runtime &rt, std::string plutus_script, std::string redeemer) {
        RPtr plutus_script_mapped = stringToRptr(plutus_script);
        RPtr redeemer_mapped = stringToRptr(redeemer);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = mint_witness_new_plutus_script(plutus_script_mapped, redeemer_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MintWitness.new_plutus_script");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::move_instantaneous_reward_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = move_instantaneous_reward_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousReward.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::move_instantaneous_reward_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = move_instantaneous_reward_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousReward.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::move_instantaneous_reward_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = move_instantaneous_reward_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousReward.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::move_instantaneous_reward_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = move_instantaneous_reward_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousReward.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::move_instantaneous_reward_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = move_instantaneous_reward_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousReward.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::move_instantaneous_reward_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = move_instantaneous_reward_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousReward.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::move_instantaneous_reward_new_to_other_pot_jsi(jsi::Runtime &rt, double pot, std::string amount) {
        int32_t pot_mapped = static_cast<int32_t>(pot);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = move_instantaneous_reward_new_to_other_pot(pot_mapped, amount_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousReward.new_to_other_pot");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::move_instantaneous_reward_new_to_stake_creds_jsi(jsi::Runtime &rt, double pot, std::string amounts) {
        int32_t pot_mapped = static_cast<int32_t>(pot);
        RPtr amounts_mapped = stringToRptr(amounts);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = move_instantaneous_reward_new_to_stake_creds(pot_mapped, amounts_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousReward.new_to_stake_creds");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::move_instantaneous_reward_pot_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int32_t ret;
        move_instantaneous_reward_pot(self_mapped, &ret, &err);
        throw_if_error(rt, err, "MoveInstantaneousReward.pot");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::move_instantaneous_reward_kind_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int32_t ret;
        move_instantaneous_reward_kind(self_mapped, &ret, &err);
        throw_if_error(rt, err, "MoveInstantaneousReward.kind");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::move_instantaneous_reward_as_to_other_pot_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = move_instantaneous_reward_as_to_other_pot(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousReward.as_to_other_pot");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::move_instantaneous_reward_as_to_stake_creds_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = move_instantaneous_reward_as_to_stake_creds(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousReward.as_to_stake_creds");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::move_instantaneous_rewards_cert_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = move_instantaneous_rewards_cert_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousRewardsCert.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::move_instantaneous_rewards_cert_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = move_instantaneous_rewards_cert_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousRewardsCert.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::move_instantaneous_rewards_cert_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = move_instantaneous_rewards_cert_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousRewardsCert.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::move_instantaneous_rewards_cert_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = move_instantaneous_rewards_cert_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousRewardsCert.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::move_instantaneous_rewards_cert_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = move_instantaneous_rewards_cert_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousRewardsCert.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::move_instantaneous_rewards_cert_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = move_instantaneous_rewards_cert_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousRewardsCert.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::move_instantaneous_rewards_cert_move_instantaneous_reward_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = move_instantaneous_rewards_cert_move_instantaneous_reward(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousRewardsCert.move_instantaneous_reward");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::move_instantaneous_rewards_cert_new_jsi(jsi::Runtime &rt, std::string move_instantaneous_reward) {
        RPtr move_instantaneous_reward_mapped = stringToRptr(move_instantaneous_reward);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = move_instantaneous_rewards_cert_new(move_instantaneous_reward_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MoveInstantaneousRewardsCert.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_asset_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = multi_asset_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiAsset.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_asset_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = multi_asset_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiAsset.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_asset_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = multi_asset_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiAsset.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_asset_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = multi_asset_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiAsset.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_asset_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = multi_asset_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiAsset.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_asset_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = multi_asset_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiAsset.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_asset_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = multi_asset_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiAsset.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::multi_asset_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        multi_asset_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "MultiAsset.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::multi_asset_insert_jsi(jsi::Runtime &rt, std::string self, std::string policy_id, std::string assets) {
        RPtr self_mapped = stringToRptr(self);
        RPtr policy_id_mapped = stringToRptr(policy_id);
        RPtr assets_mapped = stringToRptr(assets);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = multi_asset_insert(self_mapped, policy_id_mapped, assets_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiAsset.insert");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::multi_asset_get_jsi(jsi::Runtime &rt, std::string self, std::string policy_id) {
        RPtr self_mapped = stringToRptr(self);
        RPtr policy_id_mapped = stringToRptr(policy_id);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = multi_asset_get(self_mapped, policy_id_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiAsset.get");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::multi_asset_set_asset_jsi(jsi::Runtime &rt, std::string self, std::string policy_id, std::string asset_name, std::string value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr policy_id_mapped = stringToRptr(policy_id);
        RPtr asset_name_mapped = stringToRptr(asset_name);
        RPtr value_mapped = stringToRptr(value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = multi_asset_set_asset(self_mapped, policy_id_mapped, asset_name_mapped, value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiAsset.set_asset");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::multi_asset_get_asset_jsi(jsi::Runtime &rt, std::string self, std::string policy_id, std::string asset_name) {
        RPtr self_mapped = stringToRptr(self);
        RPtr policy_id_mapped = stringToRptr(policy_id);
        RPtr asset_name_mapped = stringToRptr(asset_name);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = multi_asset_get_asset(self_mapped, policy_id_mapped, asset_name_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiAsset.get_asset");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_asset_keys_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = multi_asset_keys(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiAsset.keys");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_asset_sub_jsi(jsi::Runtime &rt, std::string self, std::string rhs_ma) {
        RPtr self_mapped = stringToRptr(self);
        RPtr rhs_ma_mapped = stringToRptr(rhs_ma);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = multi_asset_sub(self_mapped, rhs_ma_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiAsset.sub");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_host_name_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = multi_host_name_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiHostName.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_host_name_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = multi_host_name_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiHostName.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_host_name_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = multi_host_name_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiHostName.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_host_name_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = multi_host_name_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiHostName.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_host_name_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = multi_host_name_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiHostName.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_host_name_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = multi_host_name_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiHostName.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_host_name_dns_name_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = multi_host_name_dns_name(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiHostName.dns_name");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::multi_host_name_new_jsi(jsi::Runtime &rt, std::string dns_name) {
        RPtr dns_name_mapped = stringToRptr(dns_name);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = multi_host_name_new(dns_name_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "MultiHostName.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_script_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = native_script_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_script_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_script_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = native_script_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_script_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_script_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = native_script_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_script_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_script_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.hash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_script_new_script_pubkey_jsi(jsi::Runtime &rt, std::string script_pubkey) {
        RPtr script_pubkey_mapped = stringToRptr(script_pubkey);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_new_script_pubkey(script_pubkey_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.new_script_pubkey");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_script_new_script_all_jsi(jsi::Runtime &rt, std::string script_all) {
        RPtr script_all_mapped = stringToRptr(script_all);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_new_script_all(script_all_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.new_script_all");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_script_new_script_any_jsi(jsi::Runtime &rt, std::string script_any) {
        RPtr script_any_mapped = stringToRptr(script_any);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_new_script_any(script_any_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.new_script_any");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_script_new_script_n_of_k_jsi(jsi::Runtime &rt, std::string script_n_of_k) {
        RPtr script_n_of_k_mapped = stringToRptr(script_n_of_k);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_new_script_n_of_k(script_n_of_k_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.new_script_n_of_k");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_script_new_timelock_start_jsi(jsi::Runtime &rt, std::string timelock_start) {
        RPtr timelock_start_mapped = stringToRptr(timelock_start);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_new_timelock_start(timelock_start_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.new_timelock_start");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_script_new_timelock_expiry_jsi(jsi::Runtime &rt, std::string timelock_expiry) {
        RPtr timelock_expiry_mapped = stringToRptr(timelock_expiry);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_new_timelock_expiry(timelock_expiry_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.new_timelock_expiry");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::native_script_kind_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int32_t ret;
        native_script_kind(self_mapped, &ret, &err);
        throw_if_error(rt, err, "NativeScript.kind");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::native_script_as_script_pubkey_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_as_script_pubkey(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.as_script_pubkey");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::native_script_as_script_all_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_as_script_all(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.as_script_all");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::native_script_as_script_any_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_as_script_any(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.as_script_any");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::native_script_as_script_n_of_k_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_as_script_n_of_k(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.as_script_n_of_k");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::native_script_as_timelock_start_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_as_timelock_start(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.as_timelock_start");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::native_script_as_timelock_expiry_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_as_timelock_expiry(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.as_timelock_expiry");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::native_script_get_required_signers_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_get_required_signers(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScript.get_required_signers");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_script_source_new_jsi(jsi::Runtime &rt, std::string script) {
        RPtr script_mapped = stringToRptr(script);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_source_new(script_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScriptSource.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_script_source_new_ref_input_jsi(jsi::Runtime &rt, std::string script_hash, std::string input, std::string required_signers) {
        RPtr script_hash_mapped = stringToRptr(script_hash);
        RPtr input_mapped = stringToRptr(input);
        RPtr required_signers_mapped = stringToRptr(required_signers);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_script_source_new_ref_input(script_hash_mapped, input_mapped, required_signers_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScriptSource.new_ref_input");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_scripts_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_scripts_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScripts.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::native_scripts_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        native_scripts_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "NativeScripts.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::native_scripts_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = native_scripts_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NativeScripts.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::native_scripts_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        native_scripts_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "NativeScripts.add");
    }

    std::string NativeCslMobileBridgeModule::network_id_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = network_id_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "NetworkId.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::network_id_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = network_id_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NetworkId.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::network_id_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = network_id_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "NetworkId.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::network_id_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = network_id_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NetworkId.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::network_id_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = network_id_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "NetworkId.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::network_id_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = network_id_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NetworkId.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::network_id_testnet_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = network_id_testnet(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NetworkId.testnet");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::network_id_mainnet_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = network_id_mainnet(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NetworkId.mainnet");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::network_id_kind_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int32_t ret;
        network_id_kind(self_mapped, &ret, &err);
        throw_if_error(rt, err, "NetworkId.kind");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::network_info_new_jsi(jsi::Runtime &rt, double network_id, double protocol_magic) {
        int64_t network_id_mapped = static_cast<int64_t>(network_id);
        int64_t protocol_magic_mapped = static_cast<int64_t>(protocol_magic);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = network_info_new(network_id_mapped, protocol_magic_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NetworkInfo.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::network_info_network_id_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        network_info_network_id(self_mapped, &ret, &err);
        throw_if_error(rt, err, "NetworkInfo.network_id");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::network_info_protocol_magic_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        network_info_protocol_magic(self_mapped, &ret, &err);
        throw_if_error(rt, err, "NetworkInfo.protocol_magic");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::network_info_testnet_preview_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = network_info_testnet_preview(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NetworkInfo.testnet_preview");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::network_info_testnet_preprod_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = network_info_testnet_preprod(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NetworkInfo.testnet_preprod");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::network_info_testnet_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = network_info_testnet(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NetworkInfo.testnet");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::network_info_mainnet_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = network_info_mainnet(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NetworkInfo.mainnet");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::new_constitution_action_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = new_constitution_action_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "NewConstitutionAction.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::new_constitution_action_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = new_constitution_action_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NewConstitutionAction.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::new_constitution_action_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = new_constitution_action_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "NewConstitutionAction.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::new_constitution_action_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = new_constitution_action_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NewConstitutionAction.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::new_constitution_action_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = new_constitution_action_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "NewConstitutionAction.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::new_constitution_action_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = new_constitution_action_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NewConstitutionAction.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::new_constitution_action_gov_action_id_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = new_constitution_action_gov_action_id(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NewConstitutionAction.gov_action_id");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::new_constitution_action_constitution_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = new_constitution_action_constitution(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NewConstitutionAction.constitution");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::new_constitution_action_new_jsi(jsi::Runtime &rt, std::string constitution) {
        RPtr constitution_mapped = stringToRptr(constitution);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = new_constitution_action_new(constitution_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NewConstitutionAction.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::new_constitution_action_new_with_action_id_jsi(jsi::Runtime &rt, std::string gov_action_id, std::string constitution) {
        RPtr gov_action_id_mapped = stringToRptr(gov_action_id);
        RPtr constitution_mapped = stringToRptr(constitution);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = new_constitution_action_new_with_action_id(gov_action_id_mapped, constitution_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NewConstitutionAction.new_with_action_id");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::no_confidence_action_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = no_confidence_action_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "NoConfidenceAction.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::no_confidence_action_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = no_confidence_action_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NoConfidenceAction.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::no_confidence_action_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = no_confidence_action_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "NoConfidenceAction.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::no_confidence_action_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = no_confidence_action_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NoConfidenceAction.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::no_confidence_action_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = no_confidence_action_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "NoConfidenceAction.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::no_confidence_action_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = no_confidence_action_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NoConfidenceAction.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::no_confidence_action_gov_action_id_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = no_confidence_action_gov_action_id(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NoConfidenceAction.gov_action_id");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::no_confidence_action_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = no_confidence_action_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NoConfidenceAction.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::no_confidence_action_new_with_action_id_jsi(jsi::Runtime &rt, std::string gov_action_id) {
        RPtr gov_action_id_mapped = stringToRptr(gov_action_id);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = no_confidence_action_new_with_action_id(gov_action_id_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "NoConfidenceAction.new_with_action_id");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::nonce_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = nonce_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Nonce.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::nonce_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = nonce_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Nonce.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::nonce_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = nonce_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Nonce.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::nonce_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = nonce_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Nonce.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::nonce_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = nonce_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Nonce.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::nonce_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = nonce_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Nonce.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::nonce_new_identity_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = nonce_new_identity(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Nonce.new_identity");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::nonce_new_from_hash_jsi(jsi::Runtime &rt, std::string hash) {
        auto hash_mapped = base64ToBytes(hash);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = nonce_new_from_hash(hash_mapped.data(), hash_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Nonce.new_from_hash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::nonce_get_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = nonce_get_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Nonce.get_hash");
        }
        if(has_ret) {
            auto mapped_ret = dataPtrToBase64(&ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::operational_cert_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = operational_cert_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "OperationalCert.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::operational_cert_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = operational_cert_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "OperationalCert.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::operational_cert_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = operational_cert_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "OperationalCert.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::operational_cert_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = operational_cert_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "OperationalCert.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::operational_cert_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = operational_cert_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "OperationalCert.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::operational_cert_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = operational_cert_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "OperationalCert.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::operational_cert_hot_vkey_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = operational_cert_hot_vkey(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "OperationalCert.hot_vkey");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::operational_cert_sequence_number_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        operational_cert_sequence_number(self_mapped, &ret, &err);
        throw_if_error(rt, err, "OperationalCert.sequence_number");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::operational_cert_kes_period_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        operational_cert_kes_period(self_mapped, &ret, &err);
        throw_if_error(rt, err, "OperationalCert.kes_period");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::operational_cert_sigma_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = operational_cert_sigma(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "OperationalCert.sigma");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::operational_cert_new_jsi(jsi::Runtime &rt, std::string hot_vkey, double sequence_number, double kes_period, std::string sigma) {
        RPtr hot_vkey_mapped = stringToRptr(hot_vkey);
        int64_t sequence_number_mapped = static_cast<int64_t>(sequence_number);
        int64_t kes_period_mapped = static_cast<int64_t>(kes_period);
        RPtr sigma_mapped = stringToRptr(sigma);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = operational_cert_new(hot_vkey_mapped, sequence_number_mapped, kes_period_mapped, sigma_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "OperationalCert.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::output_datum_new_data_hash_jsi(jsi::Runtime &rt, std::string data_hash) {
        RPtr data_hash_mapped = stringToRptr(data_hash);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = output_datum_new_data_hash(data_hash_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "OutputDatum.new_data_hash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::output_datum_new_data_jsi(jsi::Runtime &rt, std::string data) {
        RPtr data_mapped = stringToRptr(data);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = output_datum_new_data(data_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "OutputDatum.new_data");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::output_datum_data_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = output_datum_data_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "OutputDatum.data_hash");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::output_datum_data_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = output_datum_data(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "OutputDatum.data");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::parameter_change_action_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = parameter_change_action_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ParameterChangeAction.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::parameter_change_action_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = parameter_change_action_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ParameterChangeAction.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::parameter_change_action_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = parameter_change_action_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ParameterChangeAction.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::parameter_change_action_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = parameter_change_action_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ParameterChangeAction.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::parameter_change_action_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = parameter_change_action_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ParameterChangeAction.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::parameter_change_action_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = parameter_change_action_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ParameterChangeAction.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::parameter_change_action_gov_action_id_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = parameter_change_action_gov_action_id(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ParameterChangeAction.gov_action_id");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::parameter_change_action_protocol_param_updates_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = parameter_change_action_protocol_param_updates(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ParameterChangeAction.protocol_param_updates");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::parameter_change_action_new_jsi(jsi::Runtime &rt, std::string protocol_param_updates) {
        RPtr protocol_param_updates_mapped = stringToRptr(protocol_param_updates);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = parameter_change_action_new(protocol_param_updates_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ParameterChangeAction.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::parameter_change_action_new_with_action_id_jsi(jsi::Runtime &rt, std::string gov_action_id, std::string protocol_param_updates) {
        RPtr gov_action_id_mapped = stringToRptr(gov_action_id);
        RPtr protocol_param_updates_mapped = stringToRptr(protocol_param_updates);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = parameter_change_action_new_with_action_id(gov_action_id_mapped, protocol_param_updates_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ParameterChangeAction.new_with_action_id");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_data_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = plutus_data_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_data_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_data_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_data_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = plutus_data_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_data_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_data_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_data_new_constr_plutus_data_jsi(jsi::Runtime &rt, std::string constr_plutus_data) {
        RPtr constr_plutus_data_mapped = stringToRptr(constr_plutus_data);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_data_new_constr_plutus_data(constr_plutus_data_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.new_constr_plutus_data");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_data_new_empty_constr_plutus_data_jsi(jsi::Runtime &rt, std::string alternative) {
        RPtr alternative_mapped = stringToRptr(alternative);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_data_new_empty_constr_plutus_data(alternative_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.new_empty_constr_plutus_data");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_data_new_single_value_constr_plutus_data_jsi(jsi::Runtime &rt, std::string alternative, std::string plutus_data) {
        RPtr alternative_mapped = stringToRptr(alternative);
        RPtr plutus_data_mapped = stringToRptr(plutus_data);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_data_new_single_value_constr_plutus_data(alternative_mapped, plutus_data_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.new_single_value_constr_plutus_data");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_data_new_map_jsi(jsi::Runtime &rt, std::string map) {
        RPtr map_mapped = stringToRptr(map);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_data_new_map(map_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.new_map");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_data_new_list_jsi(jsi::Runtime &rt, std::string list) {
        RPtr list_mapped = stringToRptr(list);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_data_new_list(list_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.new_list");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_data_new_integer_jsi(jsi::Runtime &rt, std::string integer) {
        RPtr integer_mapped = stringToRptr(integer);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_data_new_integer(integer_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.new_integer");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_data_new_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_data_new_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.new_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::plutus_data_kind_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int32_t ret;
        plutus_data_kind(self_mapped, &ret, &err);
        throw_if_error(rt, err, "PlutusData.kind");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::plutus_data_as_constr_plutus_data_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_data_as_constr_plutus_data(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.as_constr_plutus_data");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::plutus_data_as_map_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_data_as_map(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.as_map");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::plutus_data_as_list_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_data_as_list(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.as_list");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::plutus_data_as_integer_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_data_as_integer(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.as_integer");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::plutus_data_as_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = plutus_data_as_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.as_bytes");
        }
        if(has_ret) {
            auto mapped_ret = dataPtrToBase64(&ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::plutus_data_to_json_jsi(jsi::Runtime &rt, std::string self, double schema) {
        RPtr self_mapped = stringToRptr(self);
        int32_t schema_mapped = static_cast<int32_t>(schema);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = plutus_data_to_json(self_mapped, schema_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_data_from_json_jsi(jsi::Runtime &rt, std::string json, double schema) {
        CharPtr json_mapped = stringToCharPtr(json);
        int32_t schema_mapped = static_cast<int32_t>(schema);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_data_from_json(json_mapped, schema_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_data_from_address_jsi(jsi::Runtime &rt, std::string address) {
        RPtr address_mapped = stringToRptr(address);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_data_from_address(address_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusData.from_address");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_list_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = plutus_list_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusList.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_list_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_list_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusList.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_list_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = plutus_list_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusList.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_list_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_list_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusList.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_list_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_list_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusList.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::plutus_list_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        plutus_list_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "PlutusList.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_list_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_list_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusList.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::plutus_list_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        plutus_list_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "PlutusList.add");
    }

    std::string NativeCslMobileBridgeModule::plutus_map_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = plutus_map_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusMap.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_map_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_map_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusMap.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_map_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = plutus_map_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusMap.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_map_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_map_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusMap.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_map_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_map_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusMap.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::plutus_map_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        plutus_map_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "PlutusMap.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::plutus_map_insert_jsi(jsi::Runtime &rt, std::string self, std::string key, std::string value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        RPtr value_mapped = stringToRptr(value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_map_insert(self_mapped, key_mapped, value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusMap.insert");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::plutus_map_get_jsi(jsi::Runtime &rt, std::string self, std::string key) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_map_get(self_mapped, key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusMap.get");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::plutus_map_keys_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_map_keys(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusMap.keys");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = plutus_script_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScript.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_script_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScript.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = plutus_script_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScript.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_script_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScript.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_new_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_script_new(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScript.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_new_v2_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_script_new_v2(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScript.new_v2");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_new_v3_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_script_new_v3(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScript.new_v3");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_new_with_version_jsi(jsi::Runtime &rt, std::string bytes, std::string language) {
        auto bytes_mapped = base64ToBytes(bytes);
        RPtr language_mapped = stringToRptr(language);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_script_new_with_version(bytes_mapped.data(), bytes_mapped.size(), language_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScript.new_with_version");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = plutus_script_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScript.bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_from_bytes_v2_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_script_from_bytes_v2(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScript.from_bytes_v2");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_from_bytes_v3_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_script_from_bytes_v3(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScript.from_bytes_v3");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_from_bytes_with_version_jsi(jsi::Runtime &rt, std::string bytes, std::string language) {
        auto bytes_mapped = base64ToBytes(bytes);
        RPtr language_mapped = stringToRptr(language);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_script_from_bytes_with_version(bytes_mapped.data(), bytes_mapped.size(), language_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScript.from_bytes_with_version");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_from_hex_with_version_jsi(jsi::Runtime &rt, std::string hex_str, std::string language) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        RPtr language_mapped = stringToRptr(language);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_script_from_hex_with_version(hex_str_mapped, language_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScript.from_hex_with_version");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_script_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScript.hash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_language_version_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_script_language_version(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScript.language_version");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_source_new_jsi(jsi::Runtime &rt, std::string script) {
        RPtr script_mapped = stringToRptr(script);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_script_source_new(script_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScriptSource.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_source_new_ref_input_jsi(jsi::Runtime &rt, std::string script_hash, std::string input) {
        RPtr script_hash_mapped = stringToRptr(script_hash);
        RPtr input_mapped = stringToRptr(input);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_script_source_new_ref_input(script_hash_mapped, input_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScriptSource.new_ref_input");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_script_source_new_ref_input_with_lang_ver_jsi(jsi::Runtime &rt, std::string script_hash, std::string input, std::string lang_ver) {
        RPtr script_hash_mapped = stringToRptr(script_hash);
        RPtr input_mapped = stringToRptr(input);
        RPtr lang_ver_mapped = stringToRptr(lang_ver);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_script_source_new_ref_input_with_lang_ver(script_hash_mapped, input_mapped, lang_ver_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScriptSource.new_ref_input_with_lang_ver");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_scripts_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = plutus_scripts_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScripts.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_scripts_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_scripts_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScripts.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_scripts_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = plutus_scripts_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScripts.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_scripts_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_scripts_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScripts.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_scripts_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = plutus_scripts_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScripts.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_scripts_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_scripts_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScripts.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_scripts_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_scripts_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScripts.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::plutus_scripts_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        plutus_scripts_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "PlutusScripts.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_scripts_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_scripts_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusScripts.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::plutus_scripts_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        plutus_scripts_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "PlutusScripts.add");
    }

    std::string NativeCslMobileBridgeModule::plutus_witness_new_jsi(jsi::Runtime &rt, std::string script, std::string datum, std::string redeemer) {
        RPtr script_mapped = stringToRptr(script);
        RPtr datum_mapped = stringToRptr(datum);
        RPtr redeemer_mapped = stringToRptr(redeemer);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_witness_new(script_mapped, datum_mapped, redeemer_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusWitness.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_witness_new_with_ref_jsi(jsi::Runtime &rt, std::string script, std::string datum, std::string redeemer) {
        RPtr script_mapped = stringToRptr(script);
        RPtr datum_mapped = stringToRptr(datum);
        RPtr redeemer_mapped = stringToRptr(redeemer);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_witness_new_with_ref(script_mapped, datum_mapped, redeemer_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusWitness.new_with_ref");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_witness_new_without_datum_jsi(jsi::Runtime &rt, std::string script, std::string redeemer) {
        RPtr script_mapped = stringToRptr(script);
        RPtr redeemer_mapped = stringToRptr(redeemer);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_witness_new_without_datum(script_mapped, redeemer_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusWitness.new_without_datum");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_witness_new_with_ref_without_datum_jsi(jsi::Runtime &rt, std::string script, std::string redeemer) {
        RPtr script_mapped = stringToRptr(script);
        RPtr redeemer_mapped = stringToRptr(redeemer);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_witness_new_with_ref_without_datum(script_mapped, redeemer_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusWitness.new_with_ref_without_datum");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::plutus_witness_script_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_witness_script(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusWitness.script");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::plutus_witness_datum_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_witness_datum(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusWitness.datum");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::plutus_witness_redeemer_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_witness_redeemer(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusWitness.redeemer");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_witnesses_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_witnesses_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusWitnesses.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::plutus_witnesses_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        plutus_witnesses_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "PlutusWitnesses.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::plutus_witnesses_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = plutus_witnesses_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PlutusWitnesses.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::plutus_witnesses_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        plutus_witnesses_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "PlutusWitnesses.add");
    }

    std::string NativeCslMobileBridgeModule::pointer_new_jsi(jsi::Runtime &rt, double slot, double tx_index, double cert_index) {
        int64_t slot_mapped = static_cast<int64_t>(slot);
        int64_t tx_index_mapped = static_cast<int64_t>(tx_index);
        int64_t cert_index_mapped = static_cast<int64_t>(cert_index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pointer_new(slot_mapped, tx_index_mapped, cert_index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Pointer.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pointer_new_pointer_jsi(jsi::Runtime &rt, std::string slot, std::string tx_index, std::string cert_index) {
        RPtr slot_mapped = stringToRptr(slot);
        RPtr tx_index_mapped = stringToRptr(tx_index);
        RPtr cert_index_mapped = stringToRptr(cert_index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pointer_new_pointer(slot_mapped, tx_index_mapped, cert_index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Pointer.new_pointer");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::pointer_slot_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        pointer_slot(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Pointer.slot");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::pointer_tx_index_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        pointer_tx_index(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Pointer.tx_index");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::pointer_cert_index_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        pointer_cert_index(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Pointer.cert_index");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pointer_slot_bignum_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pointer_slot_bignum(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Pointer.slot_bignum");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pointer_tx_index_bignum_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pointer_tx_index_bignum(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Pointer.tx_index_bignum");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pointer_cert_index_bignum_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pointer_cert_index_bignum(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Pointer.cert_index_bignum");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pointer_address_new_jsi(jsi::Runtime &rt, double network, std::string payment, std::string stake) {
        int64_t network_mapped = static_cast<int64_t>(network);
        RPtr payment_mapped = stringToRptr(payment);
        RPtr stake_mapped = stringToRptr(stake);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pointer_address_new(network_mapped, payment_mapped, stake_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PointerAddress.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pointer_address_payment_cred_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pointer_address_payment_cred(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PointerAddress.payment_cred");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pointer_address_stake_pointer_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pointer_address_stake_pointer(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PointerAddress.stake_pointer");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pointer_address_to_address_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pointer_address_to_address(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PointerAddress.to_address");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::pointer_address_from_address_jsi(jsi::Runtime &rt, std::string addr) {
        RPtr addr_mapped = stringToRptr(addr);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pointer_address_from_address(addr_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PointerAddress.from_address");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::pool_metadata_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = pool_metadata_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolMetadata.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_metadata_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_metadata_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolMetadata.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_metadata_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = pool_metadata_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolMetadata.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_metadata_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_metadata_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolMetadata.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_metadata_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = pool_metadata_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolMetadata.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_metadata_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_metadata_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolMetadata.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_metadata_url_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_metadata_url(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolMetadata.url");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_metadata_pool_metadata_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_metadata_pool_metadata_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolMetadata.pool_metadata_hash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_metadata_new_jsi(jsi::Runtime &rt, std::string url, std::string pool_metadata_hash) {
        RPtr url_mapped = stringToRptr(url);
        RPtr pool_metadata_hash_mapped = stringToRptr(pool_metadata_hash);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_metadata_new(url_mapped, pool_metadata_hash_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolMetadata.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_metadata_hash_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_metadata_hash_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolMetadataHash.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_metadata_hash_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = pool_metadata_hash_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolMetadataHash.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_metadata_hash_to_bech32_jsi(jsi::Runtime &rt, std::string self, std::string prefix) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr prefix_mapped = stringToCharPtr(prefix);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = pool_metadata_hash_to_bech32(self_mapped, prefix_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolMetadataHash.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_metadata_hash_from_bech32_jsi(jsi::Runtime &rt, std::string bech_str) {
        CharPtr bech_str_mapped = stringToCharPtr(bech_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_metadata_hash_from_bech32(bech_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolMetadataHash.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_metadata_hash_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = pool_metadata_hash_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolMetadataHash.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_metadata_hash_from_hex_jsi(jsi::Runtime &rt, std::string hex) {
        CharPtr hex_mapped = stringToCharPtr(hex);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_metadata_hash_from_hex(hex_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolMetadataHash.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_params_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = pool_params_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_params_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_params_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_params_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = pool_params_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_params_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_params_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_params_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = pool_params_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_params_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_params_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_params_operator_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_params_operator(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.operator");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_params_vrf_keyhash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_params_vrf_keyhash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.vrf_keyhash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_params_pledge_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_params_pledge(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.pledge");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_params_cost_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_params_cost(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.cost");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_params_margin_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_params_margin(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.margin");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_params_reward_account_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_params_reward_account(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.reward_account");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_params_pool_owners_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_params_pool_owners(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.pool_owners");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_params_relays_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_params_relays(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.relays");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::pool_params_pool_metadata_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_params_pool_metadata(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.pool_metadata");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::pool_params_new_jsi(jsi::Runtime &rt, std::string operator_arg, std::string vrf_keyhash, std::string pledge, std::string cost, std::string margin, std::string reward_account, std::string pool_owners, std::string relays) {
        RPtr operator_arg_mapped = stringToRptr(operator_arg);
        RPtr vrf_keyhash_mapped = stringToRptr(vrf_keyhash);
        RPtr pledge_mapped = stringToRptr(pledge);
        RPtr cost_mapped = stringToRptr(cost);
        RPtr margin_mapped = stringToRptr(margin);
        RPtr reward_account_mapped = stringToRptr(reward_account);
        RPtr pool_owners_mapped = stringToRptr(pool_owners);
        RPtr relays_mapped = stringToRptr(relays);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_params_new(operator_arg_mapped, vrf_keyhash_mapped, pledge_mapped, cost_mapped, margin_mapped, reward_account_mapped, pool_owners_mapped, relays_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_params_new_with_pool_metadata_jsi(jsi::Runtime &rt, std::string operator_arg, std::string vrf_keyhash, std::string pledge, std::string cost, std::string margin, std::string reward_account, std::string pool_owners, std::string relays, std::string pool_metadata) {
        RPtr operator_arg_mapped = stringToRptr(operator_arg);
        RPtr vrf_keyhash_mapped = stringToRptr(vrf_keyhash);
        RPtr pledge_mapped = stringToRptr(pledge);
        RPtr cost_mapped = stringToRptr(cost);
        RPtr margin_mapped = stringToRptr(margin);
        RPtr reward_account_mapped = stringToRptr(reward_account);
        RPtr pool_owners_mapped = stringToRptr(pool_owners);
        RPtr relays_mapped = stringToRptr(relays);
        RPtr pool_metadata_mapped = stringToRptr(pool_metadata);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_params_new_with_pool_metadata(operator_arg_mapped, vrf_keyhash_mapped, pledge_mapped, cost_mapped, margin_mapped, reward_account_mapped, pool_owners_mapped, relays_mapped, pool_metadata_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolParams.new_with_pool_metadata");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_registration_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = pool_registration_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolRegistration.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_registration_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_registration_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolRegistration.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_registration_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = pool_registration_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolRegistration.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_registration_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_registration_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolRegistration.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_registration_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = pool_registration_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolRegistration.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_registration_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_registration_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolRegistration.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_registration_pool_params_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_registration_pool_params(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolRegistration.pool_params");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_registration_new_jsi(jsi::Runtime &rt, std::string pool_params) {
        RPtr pool_params_mapped = stringToRptr(pool_params);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_registration_new(pool_params_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolRegistration.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_retirement_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = pool_retirement_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolRetirement.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_retirement_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_retirement_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolRetirement.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_retirement_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = pool_retirement_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolRetirement.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_retirement_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_retirement_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolRetirement.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_retirement_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = pool_retirement_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolRetirement.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_retirement_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_retirement_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolRetirement.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_retirement_pool_keyhash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_retirement_pool_keyhash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolRetirement.pool_keyhash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::pool_retirement_epoch_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        pool_retirement_epoch(self_mapped, &ret, &err);
        throw_if_error(rt, err, "PoolRetirement.epoch");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_retirement_new_jsi(jsi::Runtime &rt, std::string pool_keyhash, double epoch) {
        RPtr pool_keyhash_mapped = stringToRptr(pool_keyhash);
        int64_t epoch_mapped = static_cast<int64_t>(epoch);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_retirement_new(pool_keyhash_mapped, epoch_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolRetirement.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_voting_thresholds_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = pool_voting_thresholds_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolVotingThresholds.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_voting_thresholds_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_voting_thresholds_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolVotingThresholds.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_voting_thresholds_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = pool_voting_thresholds_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolVotingThresholds.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_voting_thresholds_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_voting_thresholds_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolVotingThresholds.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_voting_thresholds_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = pool_voting_thresholds_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolVotingThresholds.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_voting_thresholds_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_voting_thresholds_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolVotingThresholds.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_voting_thresholds_new_jsi(jsi::Runtime &rt, std::string motion_no_confidence, std::string committee_normal, std::string committee_no_confidence, std::string hard_fork_initiation) {
        RPtr motion_no_confidence_mapped = stringToRptr(motion_no_confidence);
        RPtr committee_normal_mapped = stringToRptr(committee_normal);
        RPtr committee_no_confidence_mapped = stringToRptr(committee_no_confidence);
        RPtr hard_fork_initiation_mapped = stringToRptr(hard_fork_initiation);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_voting_thresholds_new(motion_no_confidence_mapped, committee_normal_mapped, committee_no_confidence_mapped, hard_fork_initiation_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolVotingThresholds.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_voting_thresholds_motion_no_confidence_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_voting_thresholds_motion_no_confidence(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolVotingThresholds.motion_no_confidence");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_voting_thresholds_committee_normal_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_voting_thresholds_committee_normal(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolVotingThresholds.committee_normal");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_voting_thresholds_committee_no_confidence_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_voting_thresholds_committee_no_confidence(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolVotingThresholds.committee_no_confidence");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::pool_voting_thresholds_hard_fork_initiation_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = pool_voting_thresholds_hard_fork_initiation(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PoolVotingThresholds.hard_fork_initiation");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::private_key_to_public_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = private_key_to_public(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PrivateKey.to_public");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::private_key_generate_ed25519_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = private_key_generate_ed25519(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PrivateKey.generate_ed25519");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::private_key_generate_ed25519extended_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = private_key_generate_ed25519extended(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PrivateKey.generate_ed25519extended");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::private_key_from_bech32_jsi(jsi::Runtime &rt, std::string bech32_str) {
        CharPtr bech32_str_mapped = stringToCharPtr(bech32_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = private_key_from_bech32(bech32_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PrivateKey.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::private_key_to_bech32_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = private_key_to_bech32(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PrivateKey.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::private_key_as_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = private_key_as_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "PrivateKey.as_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::private_key_from_extended_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = private_key_from_extended_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PrivateKey.from_extended_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::private_key_from_normal_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = private_key_from_normal_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PrivateKey.from_normal_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::private_key_sign_jsi(jsi::Runtime &rt, std::string self, std::string message) {
        RPtr self_mapped = stringToRptr(self);
        auto message_mapped = base64ToBytes(message);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = private_key_sign(self_mapped, message_mapped.data(), message_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PrivateKey.sign");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::private_key_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = private_key_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PrivateKey.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::private_key_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = private_key_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PrivateKey.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::proposed_protocol_parameter_updates_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = proposed_protocol_parameter_updates_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ProposedProtocolParameterUpdates.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::proposed_protocol_parameter_updates_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = proposed_protocol_parameter_updates_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProposedProtocolParameterUpdates.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::proposed_protocol_parameter_updates_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = proposed_protocol_parameter_updates_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ProposedProtocolParameterUpdates.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::proposed_protocol_parameter_updates_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = proposed_protocol_parameter_updates_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProposedProtocolParameterUpdates.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::proposed_protocol_parameter_updates_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = proposed_protocol_parameter_updates_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ProposedProtocolParameterUpdates.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::proposed_protocol_parameter_updates_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = proposed_protocol_parameter_updates_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProposedProtocolParameterUpdates.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::proposed_protocol_parameter_updates_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = proposed_protocol_parameter_updates_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProposedProtocolParameterUpdates.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::proposed_protocol_parameter_updates_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        proposed_protocol_parameter_updates_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ProposedProtocolParameterUpdates.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::proposed_protocol_parameter_updates_insert_jsi(jsi::Runtime &rt, std::string self, std::string key, std::string value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        RPtr value_mapped = stringToRptr(value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = proposed_protocol_parameter_updates_insert(self_mapped, key_mapped, value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProposedProtocolParameterUpdates.insert");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::proposed_protocol_parameter_updates_get_jsi(jsi::Runtime &rt, std::string self, std::string key) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = proposed_protocol_parameter_updates_get(self_mapped, key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProposedProtocolParameterUpdates.get");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::proposed_protocol_parameter_updates_keys_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = proposed_protocol_parameter_updates_keys(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProposedProtocolParameterUpdates.keys");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::protocol_param_update_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = protocol_param_update_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::protocol_param_update_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::protocol_param_update_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = protocol_param_update_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::protocol_param_update_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::protocol_param_update_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = protocol_param_update_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::protocol_param_update_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_minfee_a_jsi(jsi::Runtime &rt, std::string self, std::string minfee_a) {
        RPtr self_mapped = stringToRptr(self);
        RPtr minfee_a_mapped = stringToRptr(minfee_a);
        CharPtr err = nullptr;
        protocol_param_update_set_minfee_a(self_mapped, minfee_a_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_minfee_a");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_minfee_a_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_minfee_a(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.minfee_a");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_minfee_b_jsi(jsi::Runtime &rt, std::string self, std::string minfee_b) {
        RPtr self_mapped = stringToRptr(self);
        RPtr minfee_b_mapped = stringToRptr(minfee_b);
        CharPtr err = nullptr;
        protocol_param_update_set_minfee_b(self_mapped, minfee_b_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_minfee_b");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_minfee_b_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_minfee_b(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.minfee_b");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_max_block_body_size_jsi(jsi::Runtime &rt, std::string self, double max_block_body_size) {
        RPtr self_mapped = stringToRptr(self);
        int64_t max_block_body_size_mapped = static_cast<int64_t>(max_block_body_size);
        CharPtr err = nullptr;
        protocol_param_update_set_max_block_body_size(self_mapped, max_block_body_size_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_max_block_body_size");
    }

    std::optional<double> NativeCslMobileBridgeModule::protocol_param_update_max_block_body_size_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = protocol_param_update_max_block_body_size(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.max_block_body_size");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_max_tx_size_jsi(jsi::Runtime &rt, std::string self, double max_tx_size) {
        RPtr self_mapped = stringToRptr(self);
        int64_t max_tx_size_mapped = static_cast<int64_t>(max_tx_size);
        CharPtr err = nullptr;
        protocol_param_update_set_max_tx_size(self_mapped, max_tx_size_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_max_tx_size");
    }

    std::optional<double> NativeCslMobileBridgeModule::protocol_param_update_max_tx_size_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = protocol_param_update_max_tx_size(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.max_tx_size");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_max_block_header_size_jsi(jsi::Runtime &rt, std::string self, double max_block_header_size) {
        RPtr self_mapped = stringToRptr(self);
        int64_t max_block_header_size_mapped = static_cast<int64_t>(max_block_header_size);
        CharPtr err = nullptr;
        protocol_param_update_set_max_block_header_size(self_mapped, max_block_header_size_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_max_block_header_size");
    }

    std::optional<double> NativeCslMobileBridgeModule::protocol_param_update_max_block_header_size_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = protocol_param_update_max_block_header_size(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.max_block_header_size");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_key_deposit_jsi(jsi::Runtime &rt, std::string self, std::string key_deposit) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_deposit_mapped = stringToRptr(key_deposit);
        CharPtr err = nullptr;
        protocol_param_update_set_key_deposit(self_mapped, key_deposit_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_key_deposit");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_key_deposit_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_key_deposit(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.key_deposit");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_pool_deposit_jsi(jsi::Runtime &rt, std::string self, std::string pool_deposit) {
        RPtr self_mapped = stringToRptr(self);
        RPtr pool_deposit_mapped = stringToRptr(pool_deposit);
        CharPtr err = nullptr;
        protocol_param_update_set_pool_deposit(self_mapped, pool_deposit_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_pool_deposit");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_pool_deposit_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_pool_deposit(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.pool_deposit");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_max_epoch_jsi(jsi::Runtime &rt, std::string self, double max_epoch) {
        RPtr self_mapped = stringToRptr(self);
        int64_t max_epoch_mapped = static_cast<int64_t>(max_epoch);
        CharPtr err = nullptr;
        protocol_param_update_set_max_epoch(self_mapped, max_epoch_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_max_epoch");
    }

    std::optional<double> NativeCslMobileBridgeModule::protocol_param_update_max_epoch_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = protocol_param_update_max_epoch(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.max_epoch");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_n_opt_jsi(jsi::Runtime &rt, std::string self, double n_opt) {
        RPtr self_mapped = stringToRptr(self);
        int64_t n_opt_mapped = static_cast<int64_t>(n_opt);
        CharPtr err = nullptr;
        protocol_param_update_set_n_opt(self_mapped, n_opt_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_n_opt");
    }

    std::optional<double> NativeCslMobileBridgeModule::protocol_param_update_n_opt_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = protocol_param_update_n_opt(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.n_opt");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_pool_pledge_influence_jsi(jsi::Runtime &rt, std::string self, std::string pool_pledge_influence) {
        RPtr self_mapped = stringToRptr(self);
        RPtr pool_pledge_influence_mapped = stringToRptr(pool_pledge_influence);
        CharPtr err = nullptr;
        protocol_param_update_set_pool_pledge_influence(self_mapped, pool_pledge_influence_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_pool_pledge_influence");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_pool_pledge_influence_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_pool_pledge_influence(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.pool_pledge_influence");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_expansion_rate_jsi(jsi::Runtime &rt, std::string self, std::string expansion_rate) {
        RPtr self_mapped = stringToRptr(self);
        RPtr expansion_rate_mapped = stringToRptr(expansion_rate);
        CharPtr err = nullptr;
        protocol_param_update_set_expansion_rate(self_mapped, expansion_rate_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_expansion_rate");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_expansion_rate_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_expansion_rate(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.expansion_rate");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_treasury_growth_rate_jsi(jsi::Runtime &rt, std::string self, std::string treasury_growth_rate) {
        RPtr self_mapped = stringToRptr(self);
        RPtr treasury_growth_rate_mapped = stringToRptr(treasury_growth_rate);
        CharPtr err = nullptr;
        protocol_param_update_set_treasury_growth_rate(self_mapped, treasury_growth_rate_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_treasury_growth_rate");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_treasury_growth_rate_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_treasury_growth_rate(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.treasury_growth_rate");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_d_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_d(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.d");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_extra_entropy_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_extra_entropy(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.extra_entropy");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_protocol_version_jsi(jsi::Runtime &rt, std::string self, std::string protocol_version) {
        RPtr self_mapped = stringToRptr(self);
        RPtr protocol_version_mapped = stringToRptr(protocol_version);
        CharPtr err = nullptr;
        protocol_param_update_set_protocol_version(self_mapped, protocol_version_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_protocol_version");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_protocol_version_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_protocol_version(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.protocol_version");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_min_pool_cost_jsi(jsi::Runtime &rt, std::string self, std::string min_pool_cost) {
        RPtr self_mapped = stringToRptr(self);
        RPtr min_pool_cost_mapped = stringToRptr(min_pool_cost);
        CharPtr err = nullptr;
        protocol_param_update_set_min_pool_cost(self_mapped, min_pool_cost_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_min_pool_cost");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_min_pool_cost_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_min_pool_cost(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.min_pool_cost");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_ada_per_utxo_byte_jsi(jsi::Runtime &rt, std::string self, std::string ada_per_utxo_byte) {
        RPtr self_mapped = stringToRptr(self);
        RPtr ada_per_utxo_byte_mapped = stringToRptr(ada_per_utxo_byte);
        CharPtr err = nullptr;
        protocol_param_update_set_ada_per_utxo_byte(self_mapped, ada_per_utxo_byte_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_ada_per_utxo_byte");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_ada_per_utxo_byte_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_ada_per_utxo_byte(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.ada_per_utxo_byte");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_cost_models_jsi(jsi::Runtime &rt, std::string self, std::string cost_models) {
        RPtr self_mapped = stringToRptr(self);
        RPtr cost_models_mapped = stringToRptr(cost_models);
        CharPtr err = nullptr;
        protocol_param_update_set_cost_models(self_mapped, cost_models_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_cost_models");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_cost_models_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_cost_models(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.cost_models");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_execution_costs_jsi(jsi::Runtime &rt, std::string self, std::string execution_costs) {
        RPtr self_mapped = stringToRptr(self);
        RPtr execution_costs_mapped = stringToRptr(execution_costs);
        CharPtr err = nullptr;
        protocol_param_update_set_execution_costs(self_mapped, execution_costs_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_execution_costs");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_execution_costs_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_execution_costs(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.execution_costs");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_max_tx_ex_units_jsi(jsi::Runtime &rt, std::string self, std::string max_tx_ex_units) {
        RPtr self_mapped = stringToRptr(self);
        RPtr max_tx_ex_units_mapped = stringToRptr(max_tx_ex_units);
        CharPtr err = nullptr;
        protocol_param_update_set_max_tx_ex_units(self_mapped, max_tx_ex_units_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_max_tx_ex_units");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_max_tx_ex_units_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_max_tx_ex_units(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.max_tx_ex_units");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_max_block_ex_units_jsi(jsi::Runtime &rt, std::string self, std::string max_block_ex_units) {
        RPtr self_mapped = stringToRptr(self);
        RPtr max_block_ex_units_mapped = stringToRptr(max_block_ex_units);
        CharPtr err = nullptr;
        protocol_param_update_set_max_block_ex_units(self_mapped, max_block_ex_units_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_max_block_ex_units");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_max_block_ex_units_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_max_block_ex_units(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.max_block_ex_units");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_max_value_size_jsi(jsi::Runtime &rt, std::string self, double max_value_size) {
        RPtr self_mapped = stringToRptr(self);
        int64_t max_value_size_mapped = static_cast<int64_t>(max_value_size);
        CharPtr err = nullptr;
        protocol_param_update_set_max_value_size(self_mapped, max_value_size_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_max_value_size");
    }

    std::optional<double> NativeCslMobileBridgeModule::protocol_param_update_max_value_size_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = protocol_param_update_max_value_size(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.max_value_size");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_collateral_percentage_jsi(jsi::Runtime &rt, std::string self, double collateral_percentage) {
        RPtr self_mapped = stringToRptr(self);
        int64_t collateral_percentage_mapped = static_cast<int64_t>(collateral_percentage);
        CharPtr err = nullptr;
        protocol_param_update_set_collateral_percentage(self_mapped, collateral_percentage_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_collateral_percentage");
    }

    std::optional<double> NativeCslMobileBridgeModule::protocol_param_update_collateral_percentage_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = protocol_param_update_collateral_percentage(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.collateral_percentage");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_max_collateral_inputs_jsi(jsi::Runtime &rt, std::string self, double max_collateral_inputs) {
        RPtr self_mapped = stringToRptr(self);
        int64_t max_collateral_inputs_mapped = static_cast<int64_t>(max_collateral_inputs);
        CharPtr err = nullptr;
        protocol_param_update_set_max_collateral_inputs(self_mapped, max_collateral_inputs_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_max_collateral_inputs");
    }

    std::optional<double> NativeCslMobileBridgeModule::protocol_param_update_max_collateral_inputs_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = protocol_param_update_max_collateral_inputs(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.max_collateral_inputs");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_pool_voting_thresholds_jsi(jsi::Runtime &rt, std::string self, std::string pool_voting_thresholds) {
        RPtr self_mapped = stringToRptr(self);
        RPtr pool_voting_thresholds_mapped = stringToRptr(pool_voting_thresholds);
        CharPtr err = nullptr;
        protocol_param_update_set_pool_voting_thresholds(self_mapped, pool_voting_thresholds_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_pool_voting_thresholds");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_pool_voting_thresholds_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_pool_voting_thresholds(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.pool_voting_thresholds");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_drep_voting_thresholds_jsi(jsi::Runtime &rt, std::string self, std::string drep_voting_thresholds) {
        RPtr self_mapped = stringToRptr(self);
        RPtr drep_voting_thresholds_mapped = stringToRptr(drep_voting_thresholds);
        CharPtr err = nullptr;
        protocol_param_update_set_drep_voting_thresholds(self_mapped, drep_voting_thresholds_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_drep_voting_thresholds");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_drep_voting_thresholds_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_drep_voting_thresholds(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.drep_voting_thresholds");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_min_committee_size_jsi(jsi::Runtime &rt, std::string self, double min_committee_size) {
        RPtr self_mapped = stringToRptr(self);
        int64_t min_committee_size_mapped = static_cast<int64_t>(min_committee_size);
        CharPtr err = nullptr;
        protocol_param_update_set_min_committee_size(self_mapped, min_committee_size_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_min_committee_size");
    }

    std::optional<double> NativeCslMobileBridgeModule::protocol_param_update_min_committee_size_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = protocol_param_update_min_committee_size(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.min_committee_size");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_committee_term_limit_jsi(jsi::Runtime &rt, std::string self, double committee_term_limit) {
        RPtr self_mapped = stringToRptr(self);
        int64_t committee_term_limit_mapped = static_cast<int64_t>(committee_term_limit);
        CharPtr err = nullptr;
        protocol_param_update_set_committee_term_limit(self_mapped, committee_term_limit_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_committee_term_limit");
    }

    std::optional<double> NativeCslMobileBridgeModule::protocol_param_update_committee_term_limit_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = protocol_param_update_committee_term_limit(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.committee_term_limit");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_governance_action_validity_period_jsi(jsi::Runtime &rt, std::string self, double governance_action_validity_period) {
        RPtr self_mapped = stringToRptr(self);
        int64_t governance_action_validity_period_mapped = static_cast<int64_t>(governance_action_validity_period);
        CharPtr err = nullptr;
        protocol_param_update_set_governance_action_validity_period(self_mapped, governance_action_validity_period_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_governance_action_validity_period");
    }

    std::optional<double> NativeCslMobileBridgeModule::protocol_param_update_governance_action_validity_period_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = protocol_param_update_governance_action_validity_period(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.governance_action_validity_period");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_governance_action_deposit_jsi(jsi::Runtime &rt, std::string self, std::string governance_action_deposit) {
        RPtr self_mapped = stringToRptr(self);
        RPtr governance_action_deposit_mapped = stringToRptr(governance_action_deposit);
        CharPtr err = nullptr;
        protocol_param_update_set_governance_action_deposit(self_mapped, governance_action_deposit_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_governance_action_deposit");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_governance_action_deposit_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_governance_action_deposit(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.governance_action_deposit");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_drep_deposit_jsi(jsi::Runtime &rt, std::string self, std::string drep_deposit) {
        RPtr self_mapped = stringToRptr(self);
        RPtr drep_deposit_mapped = stringToRptr(drep_deposit);
        CharPtr err = nullptr;
        protocol_param_update_set_drep_deposit(self_mapped, drep_deposit_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_drep_deposit");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::protocol_param_update_drep_deposit_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_drep_deposit(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.drep_deposit");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::protocol_param_update_set_drep_inactivity_period_jsi(jsi::Runtime &rt, std::string self, double drep_inactivity_period) {
        RPtr self_mapped = stringToRptr(self);
        int64_t drep_inactivity_period_mapped = static_cast<int64_t>(drep_inactivity_period);
        CharPtr err = nullptr;
        protocol_param_update_set_drep_inactivity_period(self_mapped, drep_inactivity_period_mapped, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.set_drep_inactivity_period");
    }

    std::optional<double> NativeCslMobileBridgeModule::protocol_param_update_drep_inactivity_period_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = protocol_param_update_drep_inactivity_period(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ProtocolParamUpdate.drep_inactivity_period");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::protocol_param_update_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_param_update_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolParamUpdate.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::protocol_version_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = protocol_version_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolVersion.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::protocol_version_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_version_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolVersion.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::protocol_version_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = protocol_version_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolVersion.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::protocol_version_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_version_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolVersion.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::protocol_version_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = protocol_version_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolVersion.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::protocol_version_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_version_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolVersion.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::protocol_version_major_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        protocol_version_major(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ProtocolVersion.major");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::protocol_version_minor_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        protocol_version_minor(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ProtocolVersion.minor");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::protocol_version_new_jsi(jsi::Runtime &rt, double major, double minor) {
        int64_t major_mapped = static_cast<int64_t>(major);
        int64_t minor_mapped = static_cast<int64_t>(minor);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = protocol_version_new(major_mapped, minor_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ProtocolVersion.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::public_key_from_bech32_jsi(jsi::Runtime &rt, std::string bech32_str) {
        CharPtr bech32_str_mapped = stringToCharPtr(bech32_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = public_key_from_bech32(bech32_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PublicKey.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::public_key_to_bech32_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = public_key_to_bech32(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PublicKey.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::public_key_as_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = public_key_as_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "PublicKey.as_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::public_key_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = public_key_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PublicKey.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::public_key_verify_jsi(jsi::Runtime &rt, std::string self, std::string data, std::string signature) {
        RPtr self_mapped = stringToRptr(self);
        auto data_mapped = base64ToBytes(data);
        RPtr signature_mapped = stringToRptr(signature);
        CharPtr err = nullptr;
        bool ret;
        public_key_verify(self_mapped, data_mapped.data(), data_mapped.size(), signature_mapped, &ret, &err);
        throw_if_error(rt, err, "PublicKey.verify");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::public_key_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = public_key_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PublicKey.hash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::public_key_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = public_key_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "PublicKey.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::public_key_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = public_key_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PublicKey.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::public_keys_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = public_keys_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PublicKeys.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::public_keys_size_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        public_keys_size(self_mapped, &ret, &err);
        throw_if_error(rt, err, "PublicKeys.size");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::public_keys_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = public_keys_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "PublicKeys.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::public_keys_add_jsi(jsi::Runtime &rt, std::string self, std::string key) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        public_keys_add(self_mapped, key_mapped, &err);
        throw_if_error(rt, err, "PublicKeys.add");
    }

    std::string NativeCslMobileBridgeModule::redeemer_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = redeemer_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemer.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemer.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = redeemer_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemer.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemer.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = redeemer_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemer.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemer.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_tag_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_tag(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemer.tag");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_index_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_index(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemer.index");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_data_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_data(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemer.data");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_ex_units_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_ex_units(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemer.ex_units");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_new_jsi(jsi::Runtime &rt, std::string tag, std::string index, std::string data, std::string ex_units) {
        RPtr tag_mapped = stringToRptr(tag);
        RPtr index_mapped = stringToRptr(index);
        RPtr data_mapped = stringToRptr(data);
        RPtr ex_units_mapped = stringToRptr(ex_units);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_new(tag_mapped, index_mapped, data_mapped, ex_units_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemer.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_tag_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = redeemer_tag_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "RedeemerTag.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_tag_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_tag_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RedeemerTag.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_tag_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = redeemer_tag_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "RedeemerTag.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_tag_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_tag_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RedeemerTag.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_tag_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = redeemer_tag_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "RedeemerTag.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_tag_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_tag_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RedeemerTag.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_tag_new_spend_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_tag_new_spend(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RedeemerTag.new_spend");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_tag_new_mint_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_tag_new_mint(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RedeemerTag.new_mint");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_tag_new_cert_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_tag_new_cert(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RedeemerTag.new_cert");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_tag_new_reward_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_tag_new_reward(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RedeemerTag.new_reward");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_tag_new_vote_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_tag_new_vote(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RedeemerTag.new_vote");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemer_tag_new_voting_proposal_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemer_tag_new_voting_proposal(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RedeemerTag.new_voting_proposal");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::redeemer_tag_kind_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int32_t ret;
        redeemer_tag_kind(self_mapped, &ret, &err);
        throw_if_error(rt, err, "RedeemerTag.kind");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemers_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = redeemers_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemers.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemers_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemers_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemers.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemers_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = redeemers_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemers.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemers_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemers_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemers.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemers_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = redeemers_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemers.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemers_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemers_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemers.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemers_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemers_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemers.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::redeemers_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        redeemers_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Redeemers.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::redeemers_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemers_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemers.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::redeemers_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        redeemers_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "Redeemers.add");
    }

    std::string NativeCslMobileBridgeModule::redeemers_total_ex_units_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = redeemers_total_ex_units(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Redeemers.total_ex_units");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::relay_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = relay_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Relay.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::relay_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = relay_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Relay.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::relay_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = relay_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Relay.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::relay_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = relay_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Relay.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::relay_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = relay_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Relay.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::relay_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = relay_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Relay.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::relay_new_single_host_addr_jsi(jsi::Runtime &rt, std::string single_host_addr) {
        RPtr single_host_addr_mapped = stringToRptr(single_host_addr);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = relay_new_single_host_addr(single_host_addr_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Relay.new_single_host_addr");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::relay_new_single_host_name_jsi(jsi::Runtime &rt, std::string single_host_name) {
        RPtr single_host_name_mapped = stringToRptr(single_host_name);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = relay_new_single_host_name(single_host_name_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Relay.new_single_host_name");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::relay_new_multi_host_name_jsi(jsi::Runtime &rt, std::string multi_host_name) {
        RPtr multi_host_name_mapped = stringToRptr(multi_host_name);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = relay_new_multi_host_name(multi_host_name_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Relay.new_multi_host_name");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::relay_kind_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int32_t ret;
        relay_kind(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Relay.kind");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::relay_as_single_host_addr_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = relay_as_single_host_addr(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Relay.as_single_host_addr");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::relay_as_single_host_name_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = relay_as_single_host_name(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Relay.as_single_host_name");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::relay_as_multi_host_name_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = relay_as_multi_host_name(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Relay.as_multi_host_name");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::relays_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = relays_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Relays.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::relays_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = relays_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Relays.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::relays_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = relays_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Relays.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::relays_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = relays_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Relays.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::relays_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = relays_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Relays.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::relays_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = relays_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Relays.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::relays_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = relays_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Relays.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::relays_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        relays_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Relays.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::relays_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = relays_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Relays.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::relays_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        relays_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "Relays.add");
    }

    std::string NativeCslMobileBridgeModule::reward_address_new_jsi(jsi::Runtime &rt, double network, std::string payment) {
        int64_t network_mapped = static_cast<int64_t>(network);
        RPtr payment_mapped = stringToRptr(payment);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = reward_address_new(network_mapped, payment_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RewardAddress.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::reward_address_payment_cred_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = reward_address_payment_cred(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RewardAddress.payment_cred");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::reward_address_to_address_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = reward_address_to_address(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RewardAddress.to_address");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::reward_address_from_address_jsi(jsi::Runtime &rt, std::string addr) {
        RPtr addr_mapped = stringToRptr(addr);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = reward_address_from_address(addr_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RewardAddress.from_address");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::reward_addresses_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = reward_addresses_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "RewardAddresses.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::reward_addresses_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = reward_addresses_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RewardAddresses.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::reward_addresses_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = reward_addresses_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "RewardAddresses.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::reward_addresses_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = reward_addresses_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RewardAddresses.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::reward_addresses_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = reward_addresses_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "RewardAddresses.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::reward_addresses_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = reward_addresses_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RewardAddresses.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::reward_addresses_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = reward_addresses_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RewardAddresses.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::reward_addresses_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        reward_addresses_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "RewardAddresses.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::reward_addresses_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = reward_addresses_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "RewardAddresses.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::reward_addresses_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        reward_addresses_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "RewardAddresses.add");
    }

    std::string NativeCslMobileBridgeModule::script_all_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = script_all_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptAll.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_all_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_all_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptAll.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_all_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = script_all_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptAll.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_all_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_all_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptAll.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_all_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = script_all_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptAll.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_all_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_all_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptAll.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_all_native_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_all_native_scripts(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptAll.native_scripts");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_all_new_jsi(jsi::Runtime &rt, std::string native_scripts) {
        RPtr native_scripts_mapped = stringToRptr(native_scripts);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_all_new(native_scripts_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptAll.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_any_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = script_any_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptAny.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_any_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_any_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptAny.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_any_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = script_any_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptAny.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_any_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_any_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptAny.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_any_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = script_any_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptAny.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_any_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_any_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptAny.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_any_native_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_any_native_scripts(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptAny.native_scripts");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_any_new_jsi(jsi::Runtime &rt, std::string native_scripts) {
        RPtr native_scripts_mapped = stringToRptr(native_scripts);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_any_new(native_scripts_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptAny.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_data_hash_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_data_hash_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptDataHash.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_data_hash_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = script_data_hash_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptDataHash.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_data_hash_to_bech32_jsi(jsi::Runtime &rt, std::string self, std::string prefix) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr prefix_mapped = stringToCharPtr(prefix);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = script_data_hash_to_bech32(self_mapped, prefix_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptDataHash.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_data_hash_from_bech32_jsi(jsi::Runtime &rt, std::string bech_str) {
        CharPtr bech_str_mapped = stringToCharPtr(bech_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_data_hash_from_bech32(bech_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptDataHash.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_data_hash_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = script_data_hash_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptDataHash.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_data_hash_from_hex_jsi(jsi::Runtime &rt, std::string hex) {
        CharPtr hex_mapped = stringToCharPtr(hex);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_data_hash_from_hex(hex_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptDataHash.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_hash_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_hash_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptHash.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_hash_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = script_hash_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptHash.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_hash_to_bech32_jsi(jsi::Runtime &rt, std::string self, std::string prefix) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr prefix_mapped = stringToCharPtr(prefix);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = script_hash_to_bech32(self_mapped, prefix_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptHash.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_hash_from_bech32_jsi(jsi::Runtime &rt, std::string bech_str) {
        CharPtr bech_str_mapped = stringToCharPtr(bech_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_hash_from_bech32(bech_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptHash.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_hash_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = script_hash_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptHash.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_hash_from_hex_jsi(jsi::Runtime &rt, std::string hex) {
        CharPtr hex_mapped = stringToCharPtr(hex);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_hash_from_hex(hex_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptHash.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_hashes_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = script_hashes_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptHashes.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_hashes_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_hashes_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptHashes.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_hashes_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = script_hashes_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptHashes.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_hashes_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_hashes_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptHashes.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_hashes_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = script_hashes_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptHashes.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_hashes_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_hashes_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptHashes.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_hashes_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_hashes_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptHashes.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::script_hashes_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        script_hashes_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ScriptHashes.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_hashes_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_hashes_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptHashes.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::script_hashes_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        script_hashes_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "ScriptHashes.add");
    }

    std::string NativeCslMobileBridgeModule::script_n_of_k_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = script_n_of_k_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptNOfK.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_n_of_k_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_n_of_k_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptNOfK.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_n_of_k_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = script_n_of_k_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptNOfK.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_n_of_k_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_n_of_k_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptNOfK.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_n_of_k_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = script_n_of_k_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptNOfK.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_n_of_k_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_n_of_k_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptNOfK.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::script_n_of_k_n_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        script_n_of_k_n(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ScriptNOfK.n");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_n_of_k_native_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_n_of_k_native_scripts(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptNOfK.native_scripts");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_n_of_k_new_jsi(jsi::Runtime &rt, double n, std::string native_scripts) {
        int64_t n_mapped = static_cast<int64_t>(n);
        RPtr native_scripts_mapped = stringToRptr(native_scripts);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_n_of_k_new(n_mapped, native_scripts_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptNOfK.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_pubkey_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = script_pubkey_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptPubkey.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_pubkey_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_pubkey_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptPubkey.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_pubkey_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = script_pubkey_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptPubkey.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_pubkey_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_pubkey_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptPubkey.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_pubkey_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = script_pubkey_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptPubkey.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_pubkey_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_pubkey_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptPubkey.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_pubkey_addr_keyhash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_pubkey_addr_keyhash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptPubkey.addr_keyhash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_pubkey_new_jsi(jsi::Runtime &rt, std::string addr_keyhash) {
        RPtr addr_keyhash_mapped = stringToRptr(addr_keyhash);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_pubkey_new(addr_keyhash_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptPubkey.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_ref_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = script_ref_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptRef.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_ref_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_ref_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptRef.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_ref_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = script_ref_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptRef.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_ref_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_ref_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptRef.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_ref_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = script_ref_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptRef.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_ref_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_ref_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptRef.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_ref_new_native_script_jsi(jsi::Runtime &rt, std::string native_script) {
        RPtr native_script_mapped = stringToRptr(native_script);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_ref_new_native_script(native_script_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptRef.new_native_script");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::script_ref_new_plutus_script_jsi(jsi::Runtime &rt, std::string plutus_script) {
        RPtr plutus_script_mapped = stringToRptr(plutus_script);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_ref_new_plutus_script(plutus_script_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptRef.new_plutus_script");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::script_ref_is_native_script_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        script_ref_is_native_script(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ScriptRef.is_native_script");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::script_ref_is_plutus_script_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        script_ref_is_plutus_script(self_mapped, &ret, &err);
        throw_if_error(rt, err, "ScriptRef.is_plutus_script");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::script_ref_native_script_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_ref_native_script(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptRef.native_script");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::script_ref_plutus_script_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = script_ref_plutus_script(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "ScriptRef.plutus_script");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::single_host_addr_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = single_host_addr_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostAddr.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_addr_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_addr_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostAddr.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_addr_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = single_host_addr_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostAddr.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_addr_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_addr_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostAddr.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_addr_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = single_host_addr_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostAddr.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_addr_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_addr_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostAddr.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<double> NativeCslMobileBridgeModule::single_host_addr_port_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = single_host_addr_port(self_mapped, &ret, &err);
        throw_if_error(rt, err, "SingleHostAddr.port");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::single_host_addr_ipv4_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_addr_ipv4(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostAddr.ipv4");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::single_host_addr_ipv6_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_addr_ipv6(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostAddr.ipv6");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::single_host_addr_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_addr_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostAddr.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_addr_new_with_port_jsi(jsi::Runtime &rt, double port) {
        int64_t port_mapped = static_cast<int64_t>(port);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_addr_new_with_port(port_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostAddr.new_with_port");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_addr_new_with_ipv4_jsi(jsi::Runtime &rt, std::string ipv4) {
        RPtr ipv4_mapped = stringToRptr(ipv4);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_addr_new_with_ipv4(ipv4_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostAddr.new_with_ipv4");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_addr_new_with_port_ipv4_jsi(jsi::Runtime &rt, double port, std::string ipv4) {
        int64_t port_mapped = static_cast<int64_t>(port);
        RPtr ipv4_mapped = stringToRptr(ipv4);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_addr_new_with_port_ipv4(port_mapped, ipv4_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostAddr.new_with_port_ipv4");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_addr_new_with_ipv6_jsi(jsi::Runtime &rt, std::string ipv6) {
        RPtr ipv6_mapped = stringToRptr(ipv6);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_addr_new_with_ipv6(ipv6_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostAddr.new_with_ipv6");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_addr_new_with_port_ipv6_jsi(jsi::Runtime &rt, double port, std::string ipv6) {
        int64_t port_mapped = static_cast<int64_t>(port);
        RPtr ipv6_mapped = stringToRptr(ipv6);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_addr_new_with_port_ipv6(port_mapped, ipv6_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostAddr.new_with_port_ipv6");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_addr_new_with_ipv4_ipv6_jsi(jsi::Runtime &rt, std::string ipv4, std::string ipv6) {
        RPtr ipv4_mapped = stringToRptr(ipv4);
        RPtr ipv6_mapped = stringToRptr(ipv6);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_addr_new_with_ipv4_ipv6(ipv4_mapped, ipv6_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostAddr.new_with_ipv4_ipv6");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_addr_new_with_port_ipv4_ipv6_jsi(jsi::Runtime &rt, double port, std::string ipv4, std::string ipv6) {
        int64_t port_mapped = static_cast<int64_t>(port);
        RPtr ipv4_mapped = stringToRptr(ipv4);
        RPtr ipv6_mapped = stringToRptr(ipv6);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_addr_new_with_port_ipv4_ipv6(port_mapped, ipv4_mapped, ipv6_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostAddr.new_with_port_ipv4_ipv6");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_name_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = single_host_name_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostName.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_name_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_name_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostName.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_name_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = single_host_name_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostName.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_name_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_name_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostName.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_name_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = single_host_name_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostName.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_name_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_name_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostName.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<double> NativeCslMobileBridgeModule::single_host_name_port_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = single_host_name_port(self_mapped, &ret, &err);
        throw_if_error(rt, err, "SingleHostName.port");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::single_host_name_dns_name_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_name_dns_name(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostName.dns_name");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_name_new_jsi(jsi::Runtime &rt, std::string dns_name) {
        RPtr dns_name_mapped = stringToRptr(dns_name);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_name_new(dns_name_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostName.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::single_host_name_new_with_port_jsi(jsi::Runtime &rt, double port, std::string dns_name) {
        int64_t port_mapped = static_cast<int64_t>(port);
        RPtr dns_name_mapped = stringToRptr(dns_name);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = single_host_name_new_with_port(port_mapped, dns_name_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "SingleHostName.new_with_port");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_and_vote_delegation_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = stake_and_vote_delegation_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeAndVoteDelegation.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_and_vote_delegation_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_and_vote_delegation_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeAndVoteDelegation.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_and_vote_delegation_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = stake_and_vote_delegation_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeAndVoteDelegation.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_and_vote_delegation_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_and_vote_delegation_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeAndVoteDelegation.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_and_vote_delegation_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = stake_and_vote_delegation_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeAndVoteDelegation.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_and_vote_delegation_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_and_vote_delegation_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeAndVoteDelegation.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_and_vote_delegation_stake_credential_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_and_vote_delegation_stake_credential(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeAndVoteDelegation.stake_credential");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_and_vote_delegation_pool_keyhash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_and_vote_delegation_pool_keyhash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeAndVoteDelegation.pool_keyhash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_and_vote_delegation_drep_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_and_vote_delegation_drep(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeAndVoteDelegation.drep");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_and_vote_delegation_new_jsi(jsi::Runtime &rt, std::string stake_credential, std::string pool_keyhash, std::string drep) {
        RPtr stake_credential_mapped = stringToRptr(stake_credential);
        RPtr pool_keyhash_mapped = stringToRptr(pool_keyhash);
        RPtr drep_mapped = stringToRptr(drep);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_and_vote_delegation_new(stake_credential_mapped, pool_keyhash_mapped, drep_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeAndVoteDelegation.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::stake_and_vote_delegation_has_script_credentials_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        stake_and_vote_delegation_has_script_credentials(self_mapped, &ret, &err);
        throw_if_error(rt, err, "StakeAndVoteDelegation.has_script_credentials");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_delegation_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = stake_delegation_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDelegation.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_delegation_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_delegation_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDelegation.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_delegation_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = stake_delegation_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDelegation.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_delegation_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_delegation_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDelegation.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_delegation_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = stake_delegation_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDelegation.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_delegation_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_delegation_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDelegation.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_delegation_stake_credential_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_delegation_stake_credential(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDelegation.stake_credential");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_delegation_pool_keyhash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_delegation_pool_keyhash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDelegation.pool_keyhash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_delegation_new_jsi(jsi::Runtime &rt, std::string stake_credential, std::string pool_keyhash) {
        RPtr stake_credential_mapped = stringToRptr(stake_credential);
        RPtr pool_keyhash_mapped = stringToRptr(pool_keyhash);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_delegation_new(stake_credential_mapped, pool_keyhash_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDelegation.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::stake_delegation_has_script_credentials_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        stake_delegation_has_script_credentials(self_mapped, &ret, &err);
        throw_if_error(rt, err, "StakeDelegation.has_script_credentials");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_deregistration_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = stake_deregistration_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDeregistration.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_deregistration_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_deregistration_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDeregistration.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_deregistration_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = stake_deregistration_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDeregistration.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_deregistration_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_deregistration_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDeregistration.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_deregistration_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = stake_deregistration_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDeregistration.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_deregistration_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_deregistration_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDeregistration.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_deregistration_stake_credential_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_deregistration_stake_credential(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDeregistration.stake_credential");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::stake_deregistration_coin_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_deregistration_coin(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDeregistration.coin");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::stake_deregistration_new_jsi(jsi::Runtime &rt, std::string stake_credential) {
        RPtr stake_credential_mapped = stringToRptr(stake_credential);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_deregistration_new(stake_credential_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDeregistration.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_deregistration_new_with_coin_jsi(jsi::Runtime &rt, std::string stake_credential, std::string coin) {
        RPtr stake_credential_mapped = stringToRptr(stake_credential);
        RPtr coin_mapped = stringToRptr(coin);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_deregistration_new_with_coin(stake_credential_mapped, coin_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeDeregistration.new_with_coin");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::stake_deregistration_has_script_credentials_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        stake_deregistration_has_script_credentials(self_mapped, &ret, &err);
        throw_if_error(rt, err, "StakeDeregistration.has_script_credentials");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = stake_registration_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistration.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_registration_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistration.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = stake_registration_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistration.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_registration_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistration.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = stake_registration_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistration.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_registration_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistration.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_stake_credential_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_registration_stake_credential(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistration.stake_credential");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::stake_registration_coin_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_registration_coin(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistration.coin");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::stake_registration_new_jsi(jsi::Runtime &rt, std::string stake_credential) {
        RPtr stake_credential_mapped = stringToRptr(stake_credential);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_registration_new(stake_credential_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistration.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_new_with_coin_jsi(jsi::Runtime &rt, std::string stake_credential, std::string coin) {
        RPtr stake_credential_mapped = stringToRptr(stake_credential);
        RPtr coin_mapped = stringToRptr(coin);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_registration_new_with_coin(stake_credential_mapped, coin_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistration.new_with_coin");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::stake_registration_has_script_credentials_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        stake_registration_has_script_credentials(self_mapped, &ret, &err);
        throw_if_error(rt, err, "StakeRegistration.has_script_credentials");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_and_delegation_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = stake_registration_and_delegation_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistrationAndDelegation.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_and_delegation_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_registration_and_delegation_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistrationAndDelegation.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_and_delegation_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = stake_registration_and_delegation_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistrationAndDelegation.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_and_delegation_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_registration_and_delegation_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistrationAndDelegation.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_and_delegation_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = stake_registration_and_delegation_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistrationAndDelegation.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_and_delegation_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_registration_and_delegation_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistrationAndDelegation.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_and_delegation_stake_credential_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_registration_and_delegation_stake_credential(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistrationAndDelegation.stake_credential");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_and_delegation_pool_keyhash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_registration_and_delegation_pool_keyhash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistrationAndDelegation.pool_keyhash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_and_delegation_coin_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_registration_and_delegation_coin(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistrationAndDelegation.coin");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_registration_and_delegation_new_jsi(jsi::Runtime &rt, std::string stake_credential, std::string pool_keyhash, std::string coin) {
        RPtr stake_credential_mapped = stringToRptr(stake_credential);
        RPtr pool_keyhash_mapped = stringToRptr(pool_keyhash);
        RPtr coin_mapped = stringToRptr(coin);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_registration_and_delegation_new(stake_credential_mapped, pool_keyhash_mapped, coin_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeRegistrationAndDelegation.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::stake_registration_and_delegation_has_script_credentials_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        stake_registration_and_delegation_has_script_credentials(self_mapped, &ret, &err);
        throw_if_error(rt, err, "StakeRegistrationAndDelegation.has_script_credentials");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_vote_registration_and_delegation_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = stake_vote_registration_and_delegation_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeVoteRegistrationAndDelegation.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_vote_registration_and_delegation_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_vote_registration_and_delegation_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeVoteRegistrationAndDelegation.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_vote_registration_and_delegation_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = stake_vote_registration_and_delegation_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeVoteRegistrationAndDelegation.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_vote_registration_and_delegation_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_vote_registration_and_delegation_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeVoteRegistrationAndDelegation.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_vote_registration_and_delegation_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = stake_vote_registration_and_delegation_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeVoteRegistrationAndDelegation.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_vote_registration_and_delegation_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_vote_registration_and_delegation_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeVoteRegistrationAndDelegation.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_vote_registration_and_delegation_stake_credential_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_vote_registration_and_delegation_stake_credential(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeVoteRegistrationAndDelegation.stake_credential");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_vote_registration_and_delegation_pool_keyhash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_vote_registration_and_delegation_pool_keyhash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeVoteRegistrationAndDelegation.pool_keyhash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_vote_registration_and_delegation_drep_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_vote_registration_and_delegation_drep(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeVoteRegistrationAndDelegation.drep");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_vote_registration_and_delegation_coin_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_vote_registration_and_delegation_coin(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeVoteRegistrationAndDelegation.coin");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::stake_vote_registration_and_delegation_new_jsi(jsi::Runtime &rt, std::string stake_credential, std::string pool_keyhash, std::string drep, std::string coin) {
        RPtr stake_credential_mapped = stringToRptr(stake_credential);
        RPtr pool_keyhash_mapped = stringToRptr(pool_keyhash);
        RPtr drep_mapped = stringToRptr(drep);
        RPtr coin_mapped = stringToRptr(coin);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = stake_vote_registration_and_delegation_new(stake_credential_mapped, pool_keyhash_mapped, drep_mapped, coin_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "StakeVoteRegistrationAndDelegation.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::stake_vote_registration_and_delegation_has_script_credentials_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        stake_vote_registration_and_delegation_has_script_credentials(self_mapped, &ret, &err);
        throw_if_error(rt, err, "StakeVoteRegistrationAndDelegation.has_script_credentials");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::strings_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = strings_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Strings.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::strings_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        strings_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Strings.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::strings_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = strings_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Strings.get");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::strings_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr elem_mapped = stringToCharPtr(elem);
        CharPtr err = nullptr;
        strings_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "Strings.add");
    }

    std::string NativeCslMobileBridgeModule::timelock_expiry_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = timelock_expiry_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockExpiry.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_expiry_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = timelock_expiry_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockExpiry.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_expiry_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = timelock_expiry_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockExpiry.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_expiry_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = timelock_expiry_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockExpiry.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_expiry_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = timelock_expiry_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockExpiry.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_expiry_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = timelock_expiry_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockExpiry.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::timelock_expiry_slot_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        timelock_expiry_slot(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TimelockExpiry.slot");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_expiry_slot_bignum_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = timelock_expiry_slot_bignum(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockExpiry.slot_bignum");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_expiry_new_jsi(jsi::Runtime &rt, double slot) {
        int64_t slot_mapped = static_cast<int64_t>(slot);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = timelock_expiry_new(slot_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockExpiry.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_expiry_new_timelockexpiry_jsi(jsi::Runtime &rt, std::string slot) {
        RPtr slot_mapped = stringToRptr(slot);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = timelock_expiry_new_timelockexpiry(slot_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockExpiry.new_timelockexpiry");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_start_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = timelock_start_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockStart.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_start_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = timelock_start_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockStart.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_start_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = timelock_start_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockStart.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_start_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = timelock_start_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockStart.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_start_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = timelock_start_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockStart.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_start_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = timelock_start_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockStart.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::timelock_start_slot_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        timelock_start_slot(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TimelockStart.slot");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_start_slot_bignum_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = timelock_start_slot_bignum(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockStart.slot_bignum");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_start_new_jsi(jsi::Runtime &rt, double slot) {
        int64_t slot_mapped = static_cast<int64_t>(slot);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = timelock_start_new(slot_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockStart.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::timelock_start_new_timelockstart_jsi(jsi::Runtime &rt, std::string slot) {
        RPtr slot_mapped = stringToRptr(slot);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = timelock_start_new_timelockstart(slot_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TimelockStart.new_timelockstart");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = transaction_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Transaction.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Transaction.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Transaction.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Transaction.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Transaction.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Transaction.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_body_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Transaction.body");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_witness_set_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_witness_set(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Transaction.witness_set");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::transaction_is_valid_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        transaction_is_valid(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Transaction.is_valid");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_auxiliary_data_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_auxiliary_data(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Transaction.auxiliary_data");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_set_is_valid_jsi(jsi::Runtime &rt, std::string self, bool valid) {
        RPtr self_mapped = stringToRptr(self);
        bool valid_mapped = static_cast<bool>(valid);
        CharPtr err = nullptr;
        transaction_set_is_valid(self_mapped, valid_mapped, &err);
        throw_if_error(rt, err, "Transaction.set_is_valid");
    }

    std::string NativeCslMobileBridgeModule::transaction_new_jsi(jsi::Runtime &rt, std::string body, std::string witness_set) {
        RPtr body_mapped = stringToRptr(body);
        RPtr witness_set_mapped = stringToRptr(witness_set);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_new(body_mapped, witness_set_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Transaction.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_new_with_auxiliary_data_jsi(jsi::Runtime &rt, std::string body, std::string witness_set, std::string auxiliary_data) {
        RPtr body_mapped = stringToRptr(body);
        RPtr witness_set_mapped = stringToRptr(witness_set);
        RPtr auxiliary_data_mapped = stringToRptr(auxiliary_data);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_new_with_auxiliary_data(body_mapped, witness_set_mapped, auxiliary_data_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Transaction.new_with_auxiliary_data");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::transaction_batch_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        transaction_batch_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionBatch.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_batch_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_batch_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBatch.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::transaction_batch_list_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        transaction_batch_list_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionBatchList.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_batch_list_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_batch_list_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBatchList.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_bodies_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = transaction_bodies_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBodies.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_bodies_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_bodies_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBodies.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_bodies_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_bodies_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBodies.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_bodies_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_bodies_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBodies.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_bodies_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_bodies_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBodies.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_bodies_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_bodies_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBodies.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_bodies_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_bodies_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBodies.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::transaction_bodies_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        transaction_bodies_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionBodies.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_bodies_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_bodies_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBodies.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::transaction_bodies_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        transaction_bodies_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "TransactionBodies.add");
    }

    std::string NativeCslMobileBridgeModule::transaction_body_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = transaction_body_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_body_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_body_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_body_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_body_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_body_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_body_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_body_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_body_inputs_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_inputs(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.inputs");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_body_outputs_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_outputs(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.outputs");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_body_fee_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_fee(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.fee");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<double> NativeCslMobileBridgeModule::transaction_body_ttl_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = transaction_body_ttl(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionBody.ttl");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_ttl_bignum_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_ttl_bignum(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.ttl_bignum");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_ttl_jsi(jsi::Runtime &rt, std::string self, std::string ttl) {
        RPtr self_mapped = stringToRptr(self);
        RPtr ttl_mapped = stringToRptr(ttl);
        CharPtr err = nullptr;
        transaction_body_set_ttl(self_mapped, ttl_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_ttl");
    }

    void NativeCslMobileBridgeModule::transaction_body_remove_ttl_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        transaction_body_remove_ttl(self_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.remove_ttl");
    }

    void NativeCslMobileBridgeModule::transaction_body_set_certs_jsi(jsi::Runtime &rt, std::string self, std::string certs) {
        RPtr self_mapped = stringToRptr(self);
        RPtr certs_mapped = stringToRptr(certs);
        CharPtr err = nullptr;
        transaction_body_set_certs(self_mapped, certs_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_certs");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_certs_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_certs(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.certs");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_withdrawals_jsi(jsi::Runtime &rt, std::string self, std::string withdrawals) {
        RPtr self_mapped = stringToRptr(self);
        RPtr withdrawals_mapped = stringToRptr(withdrawals);
        CharPtr err = nullptr;
        transaction_body_set_withdrawals(self_mapped, withdrawals_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_withdrawals");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_withdrawals_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_withdrawals(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.withdrawals");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_update_jsi(jsi::Runtime &rt, std::string self, std::string update) {
        RPtr self_mapped = stringToRptr(self);
        RPtr update_mapped = stringToRptr(update);
        CharPtr err = nullptr;
        transaction_body_set_update(self_mapped, update_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_update");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_update_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_update(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.update");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_auxiliary_data_hash_jsi(jsi::Runtime &rt, std::string self, std::string auxiliary_data_hash) {
        RPtr self_mapped = stringToRptr(self);
        RPtr auxiliary_data_hash_mapped = stringToRptr(auxiliary_data_hash);
        CharPtr err = nullptr;
        transaction_body_set_auxiliary_data_hash(self_mapped, auxiliary_data_hash_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_auxiliary_data_hash");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_auxiliary_data_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_auxiliary_data_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.auxiliary_data_hash");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_validity_start_interval_jsi(jsi::Runtime &rt, std::string self, double validity_start_interval) {
        RPtr self_mapped = stringToRptr(self);
        int64_t validity_start_interval_mapped = static_cast<int64_t>(validity_start_interval);
        CharPtr err = nullptr;
        transaction_body_set_validity_start_interval(self_mapped, validity_start_interval_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_validity_start_interval");
    }

    void NativeCslMobileBridgeModule::transaction_body_set_validity_start_interval_bignum_jsi(jsi::Runtime &rt, std::string self, std::string validity_start_interval) {
        RPtr self_mapped = stringToRptr(self);
        RPtr validity_start_interval_mapped = stringToRptr(validity_start_interval);
        CharPtr err = nullptr;
        transaction_body_set_validity_start_interval_bignum(self_mapped, validity_start_interval_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_validity_start_interval_bignum");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_validity_start_interval_bignum_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_validity_start_interval_bignum(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.validity_start_interval_bignum");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<double> NativeCslMobileBridgeModule::transaction_body_validity_start_interval_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = transaction_body_validity_start_interval(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionBody.validity_start_interval");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_mint_jsi(jsi::Runtime &rt, std::string self, std::string mint) {
        RPtr self_mapped = stringToRptr(self);
        RPtr mint_mapped = stringToRptr(mint);
        CharPtr err = nullptr;
        transaction_body_set_mint(self_mapped, mint_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_mint");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_mint_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_mint(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.mint");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_multiassets_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_multiassets(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.multiassets");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_reference_inputs_jsi(jsi::Runtime &rt, std::string self, std::string reference_inputs) {
        RPtr self_mapped = stringToRptr(self);
        RPtr reference_inputs_mapped = stringToRptr(reference_inputs);
        CharPtr err = nullptr;
        transaction_body_set_reference_inputs(self_mapped, reference_inputs_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_reference_inputs");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_reference_inputs_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_reference_inputs(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.reference_inputs");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_script_data_hash_jsi(jsi::Runtime &rt, std::string self, std::string script_data_hash) {
        RPtr self_mapped = stringToRptr(self);
        RPtr script_data_hash_mapped = stringToRptr(script_data_hash);
        CharPtr err = nullptr;
        transaction_body_set_script_data_hash(self_mapped, script_data_hash_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_script_data_hash");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_script_data_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_script_data_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.script_data_hash");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_collateral_jsi(jsi::Runtime &rt, std::string self, std::string collateral) {
        RPtr self_mapped = stringToRptr(self);
        RPtr collateral_mapped = stringToRptr(collateral);
        CharPtr err = nullptr;
        transaction_body_set_collateral(self_mapped, collateral_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_collateral");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_collateral_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_collateral(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.collateral");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_required_signers_jsi(jsi::Runtime &rt, std::string self, std::string required_signers) {
        RPtr self_mapped = stringToRptr(self);
        RPtr required_signers_mapped = stringToRptr(required_signers);
        CharPtr err = nullptr;
        transaction_body_set_required_signers(self_mapped, required_signers_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_required_signers");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_required_signers_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_required_signers(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.required_signers");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_network_id_jsi(jsi::Runtime &rt, std::string self, std::string network_id) {
        RPtr self_mapped = stringToRptr(self);
        RPtr network_id_mapped = stringToRptr(network_id);
        CharPtr err = nullptr;
        transaction_body_set_network_id(self_mapped, network_id_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_network_id");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_network_id_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_network_id(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.network_id");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_collateral_return_jsi(jsi::Runtime &rt, std::string self, std::string collateral_return) {
        RPtr self_mapped = stringToRptr(self);
        RPtr collateral_return_mapped = stringToRptr(collateral_return);
        CharPtr err = nullptr;
        transaction_body_set_collateral_return(self_mapped, collateral_return_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_collateral_return");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_collateral_return_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_collateral_return(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.collateral_return");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_total_collateral_jsi(jsi::Runtime &rt, std::string self, std::string total_collateral) {
        RPtr self_mapped = stringToRptr(self);
        RPtr total_collateral_mapped = stringToRptr(total_collateral);
        CharPtr err = nullptr;
        transaction_body_set_total_collateral(self_mapped, total_collateral_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_total_collateral");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_total_collateral_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_total_collateral(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.total_collateral");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_voting_procedures_jsi(jsi::Runtime &rt, std::string self, std::string voting_procedures) {
        RPtr self_mapped = stringToRptr(self);
        RPtr voting_procedures_mapped = stringToRptr(voting_procedures);
        CharPtr err = nullptr;
        transaction_body_set_voting_procedures(self_mapped, voting_procedures_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_voting_procedures");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_voting_procedures_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_voting_procedures(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.voting_procedures");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_voting_proposals_jsi(jsi::Runtime &rt, std::string self, std::string voting_proposals) {
        RPtr self_mapped = stringToRptr(self);
        RPtr voting_proposals_mapped = stringToRptr(voting_proposals);
        CharPtr err = nullptr;
        transaction_body_set_voting_proposals(self_mapped, voting_proposals_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_voting_proposals");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_voting_proposals_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_voting_proposals(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.voting_proposals");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_donation_jsi(jsi::Runtime &rt, std::string self, std::string donation) {
        RPtr self_mapped = stringToRptr(self);
        RPtr donation_mapped = stringToRptr(donation);
        CharPtr err = nullptr;
        transaction_body_set_donation(self_mapped, donation_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_donation");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_donation_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_donation(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.donation");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_body_set_current_treasury_value_jsi(jsi::Runtime &rt, std::string self, std::string current_treasury_value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr current_treasury_value_mapped = stringToRptr(current_treasury_value);
        CharPtr err = nullptr;
        transaction_body_set_current_treasury_value(self_mapped, current_treasury_value_mapped, &err);
        throw_if_error(rt, err, "TransactionBody.set_current_treasury_value");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_body_current_treasury_value_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_current_treasury_value(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.current_treasury_value");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::transaction_body_new_jsi(jsi::Runtime &rt, std::string inputs, std::string outputs, std::string fee) {
        RPtr inputs_mapped = stringToRptr(inputs);
        RPtr outputs_mapped = stringToRptr(outputs);
        RPtr fee_mapped = stringToRptr(fee);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_new(inputs_mapped, outputs_mapped, fee_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_body_new_with_ttl_jsi(jsi::Runtime &rt, std::string inputs, std::string outputs, std::string fee, double ttl) {
        RPtr inputs_mapped = stringToRptr(inputs);
        RPtr outputs_mapped = stringToRptr(outputs);
        RPtr fee_mapped = stringToRptr(fee);
        int64_t ttl_mapped = static_cast<int64_t>(ttl);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_new_with_ttl(inputs_mapped, outputs_mapped, fee_mapped, ttl_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.new_with_ttl");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_body_new_tx_body_jsi(jsi::Runtime &rt, std::string inputs, std::string outputs, std::string fee) {
        RPtr inputs_mapped = stringToRptr(inputs);
        RPtr outputs_mapped = stringToRptr(outputs);
        RPtr fee_mapped = stringToRptr(fee);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_body_new_tx_body(inputs_mapped, outputs_mapped, fee_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBody.new_tx_body");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_inputs_from_jsi(jsi::Runtime &rt, std::string self, std::string inputs, double strategy) {
        RPtr self_mapped = stringToRptr(self);
        RPtr inputs_mapped = stringToRptr(inputs);
        int32_t strategy_mapped = static_cast<int32_t>(strategy);
        CharPtr err = nullptr;
        transaction_builder_add_inputs_from(self_mapped, inputs_mapped, strategy_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_inputs_from");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_inputs_jsi(jsi::Runtime &rt, std::string self, std::string inputs) {
        RPtr self_mapped = stringToRptr(self);
        RPtr inputs_mapped = stringToRptr(inputs);
        CharPtr err = nullptr;
        transaction_builder_set_inputs(self_mapped, inputs_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_inputs");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_collateral_jsi(jsi::Runtime &rt, std::string self, std::string collateral) {
        RPtr self_mapped = stringToRptr(self);
        RPtr collateral_mapped = stringToRptr(collateral);
        CharPtr err = nullptr;
        transaction_builder_set_collateral(self_mapped, collateral_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_collateral");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_collateral_return_jsi(jsi::Runtime &rt, std::string self, std::string collateral_return) {
        RPtr self_mapped = stringToRptr(self);
        RPtr collateral_return_mapped = stringToRptr(collateral_return);
        CharPtr err = nullptr;
        transaction_builder_set_collateral_return(self_mapped, collateral_return_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_collateral_return");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_collateral_return_and_total_jsi(jsi::Runtime &rt, std::string self, std::string collateral_return) {
        RPtr self_mapped = stringToRptr(self);
        RPtr collateral_return_mapped = stringToRptr(collateral_return);
        CharPtr err = nullptr;
        transaction_builder_set_collateral_return_and_total(self_mapped, collateral_return_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_collateral_return_and_total");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_total_collateral_jsi(jsi::Runtime &rt, std::string self, std::string total_collateral) {
        RPtr self_mapped = stringToRptr(self);
        RPtr total_collateral_mapped = stringToRptr(total_collateral);
        CharPtr err = nullptr;
        transaction_builder_set_total_collateral(self_mapped, total_collateral_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_total_collateral");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_total_collateral_and_return_jsi(jsi::Runtime &rt, std::string self, std::string total_collateral, std::string return_address) {
        RPtr self_mapped = stringToRptr(self);
        RPtr total_collateral_mapped = stringToRptr(total_collateral);
        RPtr return_address_mapped = stringToRptr(return_address);
        CharPtr err = nullptr;
        transaction_builder_set_total_collateral_and_return(self_mapped, total_collateral_mapped, return_address_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_total_collateral_and_return");
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_reference_input_jsi(jsi::Runtime &rt, std::string self, std::string reference_input) {
        RPtr self_mapped = stringToRptr(self);
        RPtr reference_input_mapped = stringToRptr(reference_input);
        CharPtr err = nullptr;
        transaction_builder_add_reference_input(self_mapped, reference_input_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_reference_input");
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_key_input_jsi(jsi::Runtime &rt, std::string self, std::string hash, std::string input, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr hash_mapped = stringToRptr(hash);
        RPtr input_mapped = stringToRptr(input);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        transaction_builder_add_key_input(self_mapped, hash_mapped, input_mapped, amount_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_key_input");
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_script_input_jsi(jsi::Runtime &rt, std::string self, std::string hash, std::string input, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr hash_mapped = stringToRptr(hash);
        RPtr input_mapped = stringToRptr(input);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        transaction_builder_add_script_input(self_mapped, hash_mapped, input_mapped, amount_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_script_input");
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_native_script_input_jsi(jsi::Runtime &rt, std::string self, std::string script, std::string input, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr script_mapped = stringToRptr(script);
        RPtr input_mapped = stringToRptr(input);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        transaction_builder_add_native_script_input(self_mapped, script_mapped, input_mapped, amount_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_native_script_input");
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_plutus_script_input_jsi(jsi::Runtime &rt, std::string self, std::string witness, std::string input, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr witness_mapped = stringToRptr(witness);
        RPtr input_mapped = stringToRptr(input);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        transaction_builder_add_plutus_script_input(self_mapped, witness_mapped, input_mapped, amount_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_plutus_script_input");
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_bootstrap_input_jsi(jsi::Runtime &rt, std::string self, std::string hash, std::string input, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr hash_mapped = stringToRptr(hash);
        RPtr input_mapped = stringToRptr(input);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        transaction_builder_add_bootstrap_input(self_mapped, hash_mapped, input_mapped, amount_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_bootstrap_input");
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_input_jsi(jsi::Runtime &rt, std::string self, std::string address, std::string input, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr address_mapped = stringToRptr(address);
        RPtr input_mapped = stringToRptr(input);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        transaction_builder_add_input(self_mapped, address_mapped, input_mapped, amount_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_input");
    }

    double NativeCslMobileBridgeModule::transaction_builder_count_missing_input_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        transaction_builder_count_missing_input_scripts(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionBuilder.count_missing_input_scripts");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::transaction_builder_add_required_native_input_scripts_jsi(jsi::Runtime &rt, std::string self, std::string scripts) {
        RPtr self_mapped = stringToRptr(self);
        RPtr scripts_mapped = stringToRptr(scripts);
        CharPtr err = nullptr;
        int64_t ret;
        transaction_builder_add_required_native_input_scripts(self_mapped, scripts_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_required_native_input_scripts");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::transaction_builder_add_required_plutus_input_scripts_jsi(jsi::Runtime &rt, std::string self, std::string scripts) {
        RPtr self_mapped = stringToRptr(self);
        RPtr scripts_mapped = stringToRptr(scripts);
        CharPtr err = nullptr;
        int64_t ret;
        transaction_builder_add_required_plutus_input_scripts(self_mapped, scripts_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_required_plutus_input_scripts");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_builder_get_native_input_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_native_input_scripts(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_native_input_scripts");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_builder_get_plutus_input_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_plutus_input_scripts(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_plutus_input_scripts");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_fee_for_input_jsi(jsi::Runtime &rt, std::string self, std::string address, std::string input, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr address_mapped = stringToRptr(address);
        RPtr input_mapped = stringToRptr(input);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_fee_for_input(self_mapped, address_mapped, input_mapped, amount_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.fee_for_input");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_output_jsi(jsi::Runtime &rt, std::string self, std::string output) {
        RPtr self_mapped = stringToRptr(self);
        RPtr output_mapped = stringToRptr(output);
        CharPtr err = nullptr;
        transaction_builder_add_output(self_mapped, output_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_output");
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_fee_for_output_jsi(jsi::Runtime &rt, std::string self, std::string output) {
        RPtr self_mapped = stringToRptr(self);
        RPtr output_mapped = stringToRptr(output);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_fee_for_output(self_mapped, output_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.fee_for_output");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_fee_jsi(jsi::Runtime &rt, std::string self, std::string fee) {
        RPtr self_mapped = stringToRptr(self);
        RPtr fee_mapped = stringToRptr(fee);
        CharPtr err = nullptr;
        transaction_builder_set_fee(self_mapped, fee_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_fee");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_ttl_jsi(jsi::Runtime &rt, std::string self, double ttl) {
        RPtr self_mapped = stringToRptr(self);
        int64_t ttl_mapped = static_cast<int64_t>(ttl);
        CharPtr err = nullptr;
        transaction_builder_set_ttl(self_mapped, ttl_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_ttl");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_ttl_bignum_jsi(jsi::Runtime &rt, std::string self, std::string ttl) {
        RPtr self_mapped = stringToRptr(self);
        RPtr ttl_mapped = stringToRptr(ttl);
        CharPtr err = nullptr;
        transaction_builder_set_ttl_bignum(self_mapped, ttl_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_ttl_bignum");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_validity_start_interval_jsi(jsi::Runtime &rt, std::string self, double validity_start_interval) {
        RPtr self_mapped = stringToRptr(self);
        int64_t validity_start_interval_mapped = static_cast<int64_t>(validity_start_interval);
        CharPtr err = nullptr;
        transaction_builder_set_validity_start_interval(self_mapped, validity_start_interval_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_validity_start_interval");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_validity_start_interval_bignum_jsi(jsi::Runtime &rt, std::string self, std::string validity_start_interval) {
        RPtr self_mapped = stringToRptr(self);
        RPtr validity_start_interval_mapped = stringToRptr(validity_start_interval);
        CharPtr err = nullptr;
        transaction_builder_set_validity_start_interval_bignum(self_mapped, validity_start_interval_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_validity_start_interval_bignum");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_certs_jsi(jsi::Runtime &rt, std::string self, std::string certs) {
        RPtr self_mapped = stringToRptr(self);
        RPtr certs_mapped = stringToRptr(certs);
        CharPtr err = nullptr;
        transaction_builder_set_certs(self_mapped, certs_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_certs");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_certs_builder_jsi(jsi::Runtime &rt, std::string self, std::string certs) {
        RPtr self_mapped = stringToRptr(self);
        RPtr certs_mapped = stringToRptr(certs);
        CharPtr err = nullptr;
        transaction_builder_set_certs_builder(self_mapped, certs_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_certs_builder");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_withdrawals_jsi(jsi::Runtime &rt, std::string self, std::string withdrawals) {
        RPtr self_mapped = stringToRptr(self);
        RPtr withdrawals_mapped = stringToRptr(withdrawals);
        CharPtr err = nullptr;
        transaction_builder_set_withdrawals(self_mapped, withdrawals_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_withdrawals");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_withdrawals_builder_jsi(jsi::Runtime &rt, std::string self, std::string withdrawals) {
        RPtr self_mapped = stringToRptr(self);
        RPtr withdrawals_mapped = stringToRptr(withdrawals);
        CharPtr err = nullptr;
        transaction_builder_set_withdrawals_builder(self_mapped, withdrawals_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_withdrawals_builder");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_voting_builder_jsi(jsi::Runtime &rt, std::string self, std::string voting_builder) {
        RPtr self_mapped = stringToRptr(self);
        RPtr voting_builder_mapped = stringToRptr(voting_builder);
        CharPtr err = nullptr;
        transaction_builder_set_voting_builder(self_mapped, voting_builder_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_voting_builder");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_voting_proposal_builder_jsi(jsi::Runtime &rt, std::string self, std::string voting_proposal_builder) {
        RPtr self_mapped = stringToRptr(self);
        RPtr voting_proposal_builder_mapped = stringToRptr(voting_proposal_builder);
        CharPtr err = nullptr;
        transaction_builder_set_voting_proposal_builder(self_mapped, voting_proposal_builder_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_voting_proposal_builder");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_builder_get_auxiliary_data_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_auxiliary_data(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_auxiliary_data");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_auxiliary_data_jsi(jsi::Runtime &rt, std::string self, std::string auxiliary_data) {
        RPtr self_mapped = stringToRptr(self);
        RPtr auxiliary_data_mapped = stringToRptr(auxiliary_data);
        CharPtr err = nullptr;
        transaction_builder_set_auxiliary_data(self_mapped, auxiliary_data_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_auxiliary_data");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_metadata_jsi(jsi::Runtime &rt, std::string self, std::string metadata) {
        RPtr self_mapped = stringToRptr(self);
        RPtr metadata_mapped = stringToRptr(metadata);
        CharPtr err = nullptr;
        transaction_builder_set_metadata(self_mapped, metadata_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_metadata");
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_metadatum_jsi(jsi::Runtime &rt, std::string self, std::string key, std::string val) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        RPtr val_mapped = stringToRptr(val);
        CharPtr err = nullptr;
        transaction_builder_add_metadatum(self_mapped, key_mapped, val_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_metadatum");
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_json_metadatum_jsi(jsi::Runtime &rt, std::string self, std::string key, std::string val) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr val_mapped = stringToCharPtr(val);
        CharPtr err = nullptr;
        transaction_builder_add_json_metadatum(self_mapped, key_mapped, val_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_json_metadatum");
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_json_metadatum_with_schema_jsi(jsi::Runtime &rt, std::string self, std::string key, std::string val, double schema) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr val_mapped = stringToCharPtr(val);
        int32_t schema_mapped = static_cast<int32_t>(schema);
        CharPtr err = nullptr;
        transaction_builder_add_json_metadatum_with_schema(self_mapped, key_mapped, val_mapped, schema_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_json_metadatum_with_schema");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_mint_builder_jsi(jsi::Runtime &rt, std::string self, std::string mint_builder) {
        RPtr self_mapped = stringToRptr(self);
        RPtr mint_builder_mapped = stringToRptr(mint_builder);
        CharPtr err = nullptr;
        transaction_builder_set_mint_builder(self_mapped, mint_builder_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_mint_builder");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_builder_get_mint_builder_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_mint_builder(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_mint_builder");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_mint_jsi(jsi::Runtime &rt, std::string self, std::string mint, std::string mint_scripts) {
        RPtr self_mapped = stringToRptr(self);
        RPtr mint_mapped = stringToRptr(mint);
        RPtr mint_scripts_mapped = stringToRptr(mint_scripts);
        CharPtr err = nullptr;
        transaction_builder_set_mint(self_mapped, mint_mapped, mint_scripts_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_mint");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_builder_get_mint_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_mint(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_mint");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_builder_get_mint_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_mint_scripts(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_mint_scripts");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_mint_asset_jsi(jsi::Runtime &rt, std::string self, std::string policy_script, std::string mint_assets) {
        RPtr self_mapped = stringToRptr(self);
        RPtr policy_script_mapped = stringToRptr(policy_script);
        RPtr mint_assets_mapped = stringToRptr(mint_assets);
        CharPtr err = nullptr;
        transaction_builder_set_mint_asset(self_mapped, policy_script_mapped, mint_assets_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_mint_asset");
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_mint_asset_jsi(jsi::Runtime &rt, std::string self, std::string policy_script, std::string asset_name, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr policy_script_mapped = stringToRptr(policy_script);
        RPtr asset_name_mapped = stringToRptr(asset_name);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        transaction_builder_add_mint_asset(self_mapped, policy_script_mapped, asset_name_mapped, amount_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_mint_asset");
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_mint_asset_and_output_jsi(jsi::Runtime &rt, std::string self, std::string policy_script, std::string asset_name, std::string amount, std::string output_builder, std::string output_coin) {
        RPtr self_mapped = stringToRptr(self);
        RPtr policy_script_mapped = stringToRptr(policy_script);
        RPtr asset_name_mapped = stringToRptr(asset_name);
        RPtr amount_mapped = stringToRptr(amount);
        RPtr output_builder_mapped = stringToRptr(output_builder);
        RPtr output_coin_mapped = stringToRptr(output_coin);
        CharPtr err = nullptr;
        transaction_builder_add_mint_asset_and_output(self_mapped, policy_script_mapped, asset_name_mapped, amount_mapped, output_builder_mapped, output_coin_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_mint_asset_and_output");
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_mint_asset_and_output_min_required_coin_jsi(jsi::Runtime &rt, std::string self, std::string policy_script, std::string asset_name, std::string amount, std::string output_builder) {
        RPtr self_mapped = stringToRptr(self);
        RPtr policy_script_mapped = stringToRptr(policy_script);
        RPtr asset_name_mapped = stringToRptr(asset_name);
        RPtr amount_mapped = stringToRptr(amount);
        RPtr output_builder_mapped = stringToRptr(output_builder);
        CharPtr err = nullptr;
        transaction_builder_add_mint_asset_and_output_min_required_coin(self_mapped, policy_script_mapped, asset_name_mapped, amount_mapped, output_builder_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_mint_asset_and_output_min_required_coin");
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_extra_witness_datum_jsi(jsi::Runtime &rt, std::string self, std::string datum) {
        RPtr self_mapped = stringToRptr(self);
        RPtr datum_mapped = stringToRptr(datum);
        CharPtr err = nullptr;
        transaction_builder_add_extra_witness_datum(self_mapped, datum_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_extra_witness_datum");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_builder_get_extra_witness_datums_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_extra_witness_datums(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_extra_witness_datums");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_donation_jsi(jsi::Runtime &rt, std::string self, std::string donation) {
        RPtr self_mapped = stringToRptr(self);
        RPtr donation_mapped = stringToRptr(donation);
        CharPtr err = nullptr;
        transaction_builder_set_donation(self_mapped, donation_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_donation");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_builder_get_donation_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_donation(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_donation");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_current_treasury_value_jsi(jsi::Runtime &rt, std::string self, std::string current_treasury_value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr current_treasury_value_mapped = stringToRptr(current_treasury_value);
        CharPtr err = nullptr;
        transaction_builder_set_current_treasury_value(self_mapped, current_treasury_value_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_current_treasury_value");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_builder_get_current_treasury_value_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_current_treasury_value(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_current_treasury_value");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_new_jsi(jsi::Runtime &rt, std::string cfg) {
        RPtr cfg_mapped = stringToRptr(cfg);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_new(cfg_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_get_reference_inputs_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_reference_inputs(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_reference_inputs");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_get_explicit_input_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_explicit_input(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_explicit_input");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_get_implicit_input_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_implicit_input(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_implicit_input");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_get_total_input_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_total_input(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_total_input");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_get_total_output_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_total_output(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_total_output");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_get_explicit_output_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_explicit_output(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_explicit_output");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_get_deposit_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_deposit(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_deposit");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_builder_get_fee_if_set_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_get_fee_if_set(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.get_fee_if_set");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    bool NativeCslMobileBridgeModule::transaction_builder_add_change_if_needed_jsi(jsi::Runtime &rt, std::string self, std::string address) {
        RPtr self_mapped = stringToRptr(self);
        RPtr address_mapped = stringToRptr(address);
        CharPtr err = nullptr;
        bool ret;
        transaction_builder_add_change_if_needed(self_mapped, address_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_change_if_needed");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::transaction_builder_add_change_if_needed_with_datum_jsi(jsi::Runtime &rt, std::string self, std::string address, std::string plutus_data) {
        RPtr self_mapped = stringToRptr(self);
        RPtr address_mapped = stringToRptr(address);
        RPtr plutus_data_mapped = stringToRptr(plutus_data);
        CharPtr err = nullptr;
        bool ret;
        transaction_builder_add_change_if_needed_with_datum(self_mapped, address_mapped, plutus_data_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_change_if_needed_with_datum");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::transaction_builder_calc_script_data_hash_jsi(jsi::Runtime &rt, std::string self, std::string cost_models) {
        RPtr self_mapped = stringToRptr(self);
        RPtr cost_models_mapped = stringToRptr(cost_models);
        CharPtr err = nullptr;
        transaction_builder_calc_script_data_hash(self_mapped, cost_models_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.calc_script_data_hash");
    }

    void NativeCslMobileBridgeModule::transaction_builder_set_script_data_hash_jsi(jsi::Runtime &rt, std::string self, std::string hash) {
        RPtr self_mapped = stringToRptr(self);
        RPtr hash_mapped = stringToRptr(hash);
        CharPtr err = nullptr;
        transaction_builder_set_script_data_hash(self_mapped, hash_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.set_script_data_hash");
    }

    void NativeCslMobileBridgeModule::transaction_builder_remove_script_data_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        transaction_builder_remove_script_data_hash(self_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.remove_script_data_hash");
    }

    void NativeCslMobileBridgeModule::transaction_builder_add_required_signer_jsi(jsi::Runtime &rt, std::string self, std::string key) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        transaction_builder_add_required_signer(self_mapped, key_mapped, &err);
        throw_if_error(rt, err, "TransactionBuilder.add_required_signer");
    }

    double NativeCslMobileBridgeModule::transaction_builder_full_size_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        transaction_builder_full_size(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionBuilder.full_size");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_output_sizes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_builder_output_sizes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.output_sizes");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_build_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_build(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.build");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_build_tx_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_build_tx(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.build_tx");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_build_tx_unsafe_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_build_tx_unsafe(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.build_tx_unsafe");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_min_fee_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_min_fee(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilder.min_fee");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_config_builder_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_config_builder_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilderConfigBuilder.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_config_builder_fee_algo_jsi(jsi::Runtime &rt, std::string self, std::string fee_algo) {
        RPtr self_mapped = stringToRptr(self);
        RPtr fee_algo_mapped = stringToRptr(fee_algo);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_config_builder_fee_algo(self_mapped, fee_algo_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilderConfigBuilder.fee_algo");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_config_builder_coins_per_utxo_word_jsi(jsi::Runtime &rt, std::string self, std::string coins_per_utxo_word) {
        RPtr self_mapped = stringToRptr(self);
        RPtr coins_per_utxo_word_mapped = stringToRptr(coins_per_utxo_word);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_config_builder_coins_per_utxo_word(self_mapped, coins_per_utxo_word_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilderConfigBuilder.coins_per_utxo_word");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_config_builder_coins_per_utxo_byte_jsi(jsi::Runtime &rt, std::string self, std::string coins_per_utxo_byte) {
        RPtr self_mapped = stringToRptr(self);
        RPtr coins_per_utxo_byte_mapped = stringToRptr(coins_per_utxo_byte);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_config_builder_coins_per_utxo_byte(self_mapped, coins_per_utxo_byte_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilderConfigBuilder.coins_per_utxo_byte");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_config_builder_ex_unit_prices_jsi(jsi::Runtime &rt, std::string self, std::string ex_unit_prices) {
        RPtr self_mapped = stringToRptr(self);
        RPtr ex_unit_prices_mapped = stringToRptr(ex_unit_prices);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_config_builder_ex_unit_prices(self_mapped, ex_unit_prices_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilderConfigBuilder.ex_unit_prices");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_config_builder_pool_deposit_jsi(jsi::Runtime &rt, std::string self, std::string pool_deposit) {
        RPtr self_mapped = stringToRptr(self);
        RPtr pool_deposit_mapped = stringToRptr(pool_deposit);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_config_builder_pool_deposit(self_mapped, pool_deposit_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilderConfigBuilder.pool_deposit");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_config_builder_key_deposit_jsi(jsi::Runtime &rt, std::string self, std::string key_deposit) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_deposit_mapped = stringToRptr(key_deposit);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_config_builder_key_deposit(self_mapped, key_deposit_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilderConfigBuilder.key_deposit");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_config_builder_max_value_size_jsi(jsi::Runtime &rt, std::string self, double max_value_size) {
        RPtr self_mapped = stringToRptr(self);
        int64_t max_value_size_mapped = static_cast<int64_t>(max_value_size);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_config_builder_max_value_size(self_mapped, max_value_size_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilderConfigBuilder.max_value_size");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_config_builder_max_tx_size_jsi(jsi::Runtime &rt, std::string self, double max_tx_size) {
        RPtr self_mapped = stringToRptr(self);
        int64_t max_tx_size_mapped = static_cast<int64_t>(max_tx_size);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_config_builder_max_tx_size(self_mapped, max_tx_size_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilderConfigBuilder.max_tx_size");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_config_builder_prefer_pure_change_jsi(jsi::Runtime &rt, std::string self, bool prefer_pure_change) {
        RPtr self_mapped = stringToRptr(self);
        bool prefer_pure_change_mapped = static_cast<bool>(prefer_pure_change);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_config_builder_prefer_pure_change(self_mapped, prefer_pure_change_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilderConfigBuilder.prefer_pure_change");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_builder_config_builder_build_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_builder_config_builder_build(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionBuilderConfigBuilder.build");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_hash_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_hash_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionHash.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_hash_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = transaction_hash_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionHash.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_hash_to_bech32_jsi(jsi::Runtime &rt, std::string self, std::string prefix) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr prefix_mapped = stringToCharPtr(prefix);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_hash_to_bech32(self_mapped, prefix_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionHash.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_hash_from_bech32_jsi(jsi::Runtime &rt, std::string bech_str) {
        CharPtr bech_str_mapped = stringToCharPtr(bech_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_hash_from_bech32(bech_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionHash.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_hash_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_hash_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionHash.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_hash_from_hex_jsi(jsi::Runtime &rt, std::string hex) {
        CharPtr hex_mapped = stringToCharPtr(hex);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_hash_from_hex(hex_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionHash.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_input_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = transaction_input_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInput.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_input_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_input_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInput.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_input_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_input_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInput.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_input_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_input_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInput.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_input_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_input_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInput.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_input_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_input_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInput.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_input_transaction_id_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_input_transaction_id(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInput.transaction_id");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::transaction_input_index_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        transaction_input_index(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionInput.index");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_input_new_jsi(jsi::Runtime &rt, std::string transaction_id, double index) {
        RPtr transaction_id_mapped = stringToRptr(transaction_id);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_input_new(transaction_id_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInput.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_inputs_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = transaction_inputs_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInputs.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_inputs_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_inputs_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInputs.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_inputs_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_inputs_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInputs.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_inputs_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_inputs_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInputs.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_inputs_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_inputs_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInputs.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_inputs_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_inputs_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInputs.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_inputs_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_inputs_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInputs.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::transaction_inputs_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        transaction_inputs_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionInputs.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_inputs_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_inputs_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInputs.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::transaction_inputs_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        transaction_inputs_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "TransactionInputs.add");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_inputs_to_option_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_inputs_to_option(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionInputs.to_option");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = transaction_metadatum_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatum.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_metadatum_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatum.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_metadatum_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatum.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_metadatum_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatum.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_new_map_jsi(jsi::Runtime &rt, std::string map) {
        RPtr map_mapped = stringToRptr(map);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_metadatum_new_map(map_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatum.new_map");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_new_list_jsi(jsi::Runtime &rt, std::string list) {
        RPtr list_mapped = stringToRptr(list);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_metadatum_new_list(list_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatum.new_list");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_new_int_jsi(jsi::Runtime &rt, std::string int_value) {
        RPtr int_value_mapped = stringToRptr(int_value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_metadatum_new_int(int_value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatum.new_int");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_new_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_metadatum_new_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatum.new_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_new_text_jsi(jsi::Runtime &rt, std::string text) {
        CharPtr text_mapped = stringToCharPtr(text);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_metadatum_new_text(text_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatum.new_text");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::transaction_metadatum_kind_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int32_t ret;
        transaction_metadatum_kind(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionMetadatum.kind");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_as_map_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_metadatum_as_map(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatum.as_map");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_as_list_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_metadatum_as_list(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatum.as_list");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_as_int_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_metadatum_as_int(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatum.as_int");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_as_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = transaction_metadatum_as_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatum.as_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_as_text_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_metadatum_as_text(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatum.as_text");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_labels_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = transaction_metadatum_labels_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatumLabels.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_labels_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_metadatum_labels_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatumLabels.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_labels_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_metadatum_labels_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatumLabels.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_labels_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_metadatum_labels_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatumLabels.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_labels_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_metadatum_labels_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatumLabels.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::transaction_metadatum_labels_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        transaction_metadatum_labels_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionMetadatumLabels.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_metadatum_labels_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_metadatum_labels_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionMetadatumLabels.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::transaction_metadatum_labels_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        transaction_metadatum_labels_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "TransactionMetadatumLabels.add");
    }

    std::string NativeCslMobileBridgeModule::transaction_output_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = transaction_output_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutput.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutput.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_output_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutput.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutput.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_output_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutput.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutput.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_address_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_address(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutput.address");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_amount_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_amount(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutput.amount");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_output_data_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_data_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutput.data_hash");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_output_plutus_data_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_plutus_data(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutput.plutus_data");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_output_script_ref_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_script_ref(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutput.script_ref");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_output_set_script_ref_jsi(jsi::Runtime &rt, std::string self, std::string script_ref) {
        RPtr self_mapped = stringToRptr(self);
        RPtr script_ref_mapped = stringToRptr(script_ref);
        CharPtr err = nullptr;
        transaction_output_set_script_ref(self_mapped, script_ref_mapped, &err);
        throw_if_error(rt, err, "TransactionOutput.set_script_ref");
    }

    void NativeCslMobileBridgeModule::transaction_output_set_plutus_data_jsi(jsi::Runtime &rt, std::string self, std::string data) {
        RPtr self_mapped = stringToRptr(self);
        RPtr data_mapped = stringToRptr(data);
        CharPtr err = nullptr;
        transaction_output_set_plutus_data(self_mapped, data_mapped, &err);
        throw_if_error(rt, err, "TransactionOutput.set_plutus_data");
    }

    void NativeCslMobileBridgeModule::transaction_output_set_data_hash_jsi(jsi::Runtime &rt, std::string self, std::string data_hash) {
        RPtr self_mapped = stringToRptr(self);
        RPtr data_hash_mapped = stringToRptr(data_hash);
        CharPtr err = nullptr;
        transaction_output_set_data_hash(self_mapped, data_hash_mapped, &err);
        throw_if_error(rt, err, "TransactionOutput.set_data_hash");
    }

    bool NativeCslMobileBridgeModule::transaction_output_has_plutus_data_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        transaction_output_has_plutus_data(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionOutput.has_plutus_data");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::transaction_output_has_data_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        transaction_output_has_data_hash(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionOutput.has_data_hash");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::transaction_output_has_script_ref_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        transaction_output_has_script_ref(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionOutput.has_script_ref");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_new_jsi(jsi::Runtime &rt, std::string address, std::string amount) {
        RPtr address_mapped = stringToRptr(address);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_new(address_mapped, amount_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutput.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<double> NativeCslMobileBridgeModule::transaction_output_serialization_format_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int32_t ret;
        bool has_ret = transaction_output_serialization_format(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionOutput.serialization_format");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::transaction_output_amount_builder_with_value_jsi(jsi::Runtime &rt, std::string self, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_amount_builder_with_value(self_mapped, amount_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputAmountBuilder.with_value");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_amount_builder_with_coin_jsi(jsi::Runtime &rt, std::string self, std::string coin) {
        RPtr self_mapped = stringToRptr(self);
        RPtr coin_mapped = stringToRptr(coin);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_amount_builder_with_coin(self_mapped, coin_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputAmountBuilder.with_coin");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_amount_builder_with_coin_and_asset_jsi(jsi::Runtime &rt, std::string self, std::string coin, std::string multiasset) {
        RPtr self_mapped = stringToRptr(self);
        RPtr coin_mapped = stringToRptr(coin);
        RPtr multiasset_mapped = stringToRptr(multiasset);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_amount_builder_with_coin_and_asset(self_mapped, coin_mapped, multiasset_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputAmountBuilder.with_coin_and_asset");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_amount_builder_with_asset_and_min_required_coin_jsi(jsi::Runtime &rt, std::string self, std::string multiasset, std::string coins_per_utxo_word) {
        RPtr self_mapped = stringToRptr(self);
        RPtr multiasset_mapped = stringToRptr(multiasset);
        RPtr coins_per_utxo_word_mapped = stringToRptr(coins_per_utxo_word);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_amount_builder_with_asset_and_min_required_coin(self_mapped, multiasset_mapped, coins_per_utxo_word_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputAmountBuilder.with_asset_and_min_required_coin");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_amount_builder_with_asset_and_min_required_coin_by_utxo_cost_jsi(jsi::Runtime &rt, std::string self, std::string multiasset, std::string data_cost) {
        RPtr self_mapped = stringToRptr(self);
        RPtr multiasset_mapped = stringToRptr(multiasset);
        RPtr data_cost_mapped = stringToRptr(data_cost);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_amount_builder_with_asset_and_min_required_coin_by_utxo_cost(self_mapped, multiasset_mapped, data_cost_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputAmountBuilder.with_asset_and_min_required_coin_by_utxo_cost");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_amount_builder_build_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_amount_builder_build(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputAmountBuilder.build");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_builder_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_builder_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputBuilder.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_builder_with_address_jsi(jsi::Runtime &rt, std::string self, std::string address) {
        RPtr self_mapped = stringToRptr(self);
        RPtr address_mapped = stringToRptr(address);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_builder_with_address(self_mapped, address_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputBuilder.with_address");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_builder_with_data_hash_jsi(jsi::Runtime &rt, std::string self, std::string data_hash) {
        RPtr self_mapped = stringToRptr(self);
        RPtr data_hash_mapped = stringToRptr(data_hash);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_builder_with_data_hash(self_mapped, data_hash_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputBuilder.with_data_hash");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_builder_with_plutus_data_jsi(jsi::Runtime &rt, std::string self, std::string data) {
        RPtr self_mapped = stringToRptr(self);
        RPtr data_mapped = stringToRptr(data);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_builder_with_plutus_data(self_mapped, data_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputBuilder.with_plutus_data");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_builder_with_script_ref_jsi(jsi::Runtime &rt, std::string self, std::string script_ref) {
        RPtr self_mapped = stringToRptr(self);
        RPtr script_ref_mapped = stringToRptr(script_ref);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_builder_with_script_ref(self_mapped, script_ref_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputBuilder.with_script_ref");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_output_builder_next_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_output_builder_next(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputBuilder.next");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_outputs_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = transaction_outputs_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputs.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_outputs_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_outputs_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputs.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_outputs_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_outputs_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputs.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_outputs_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_outputs_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputs.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_outputs_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_outputs_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputs.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_outputs_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_outputs_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputs.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_outputs_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_outputs_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputs.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::transaction_outputs_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        transaction_outputs_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionOutputs.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_outputs_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_outputs_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionOutputs.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::transaction_outputs_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        transaction_outputs_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "TransactionOutputs.add");
    }

    std::string NativeCslMobileBridgeModule::transaction_unspent_output_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = transaction_unspent_output_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionUnspentOutput.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_unspent_output_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_unspent_output_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionUnspentOutput.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_unspent_output_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_unspent_output_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionUnspentOutput.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_unspent_output_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_unspent_output_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionUnspentOutput.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_unspent_output_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_unspent_output_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionUnspentOutput.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_unspent_output_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_unspent_output_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionUnspentOutput.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_unspent_output_new_jsi(jsi::Runtime &rt, std::string input, std::string output) {
        RPtr input_mapped = stringToRptr(input);
        RPtr output_mapped = stringToRptr(output);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_unspent_output_new(input_mapped, output_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionUnspentOutput.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_unspent_output_input_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_unspent_output_input(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionUnspentOutput.input");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_unspent_output_output_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_unspent_output_output(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionUnspentOutput.output");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_unspent_outputs_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_unspent_outputs_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionUnspentOutputs.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_unspent_outputs_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_unspent_outputs_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionUnspentOutputs.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_unspent_outputs_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_unspent_outputs_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionUnspentOutputs.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::transaction_unspent_outputs_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        transaction_unspent_outputs_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionUnspentOutputs.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_unspent_outputs_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_unspent_outputs_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionUnspentOutputs.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::transaction_unspent_outputs_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        transaction_unspent_outputs_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "TransactionUnspentOutputs.add");
    }

    std::string NativeCslMobileBridgeModule::transaction_witness_set_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = transaction_witness_set_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSet.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_witness_set_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_witness_set_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSet.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_witness_set_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_witness_set_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSet.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_witness_set_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_witness_set_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSet.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_witness_set_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_witness_set_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSet.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_witness_set_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_witness_set_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSet.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::transaction_witness_set_set_vkeys_jsi(jsi::Runtime &rt, std::string self, std::string vkeys) {
        RPtr self_mapped = stringToRptr(self);
        RPtr vkeys_mapped = stringToRptr(vkeys);
        CharPtr err = nullptr;
        transaction_witness_set_set_vkeys(self_mapped, vkeys_mapped, &err);
        throw_if_error(rt, err, "TransactionWitnessSet.set_vkeys");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_witness_set_vkeys_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_witness_set_vkeys(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSet.vkeys");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_witness_set_set_native_scripts_jsi(jsi::Runtime &rt, std::string self, std::string native_scripts) {
        RPtr self_mapped = stringToRptr(self);
        RPtr native_scripts_mapped = stringToRptr(native_scripts);
        CharPtr err = nullptr;
        transaction_witness_set_set_native_scripts(self_mapped, native_scripts_mapped, &err);
        throw_if_error(rt, err, "TransactionWitnessSet.set_native_scripts");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_witness_set_native_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_witness_set_native_scripts(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSet.native_scripts");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_witness_set_set_bootstraps_jsi(jsi::Runtime &rt, std::string self, std::string bootstraps) {
        RPtr self_mapped = stringToRptr(self);
        RPtr bootstraps_mapped = stringToRptr(bootstraps);
        CharPtr err = nullptr;
        transaction_witness_set_set_bootstraps(self_mapped, bootstraps_mapped, &err);
        throw_if_error(rt, err, "TransactionWitnessSet.set_bootstraps");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_witness_set_bootstraps_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_witness_set_bootstraps(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSet.bootstraps");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_witness_set_set_plutus_scripts_jsi(jsi::Runtime &rt, std::string self, std::string plutus_scripts) {
        RPtr self_mapped = stringToRptr(self);
        RPtr plutus_scripts_mapped = stringToRptr(plutus_scripts);
        CharPtr err = nullptr;
        transaction_witness_set_set_plutus_scripts(self_mapped, plutus_scripts_mapped, &err);
        throw_if_error(rt, err, "TransactionWitnessSet.set_plutus_scripts");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_witness_set_plutus_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_witness_set_plutus_scripts(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSet.plutus_scripts");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_witness_set_set_plutus_data_jsi(jsi::Runtime &rt, std::string self, std::string plutus_data) {
        RPtr self_mapped = stringToRptr(self);
        RPtr plutus_data_mapped = stringToRptr(plutus_data);
        CharPtr err = nullptr;
        transaction_witness_set_set_plutus_data(self_mapped, plutus_data_mapped, &err);
        throw_if_error(rt, err, "TransactionWitnessSet.set_plutus_data");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_witness_set_plutus_data_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_witness_set_plutus_data(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSet.plutus_data");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::transaction_witness_set_set_redeemers_jsi(jsi::Runtime &rt, std::string self, std::string redeemers) {
        RPtr self_mapped = stringToRptr(self);
        RPtr redeemers_mapped = stringToRptr(redeemers);
        CharPtr err = nullptr;
        transaction_witness_set_set_redeemers(self_mapped, redeemers_mapped, &err);
        throw_if_error(rt, err, "TransactionWitnessSet.set_redeemers");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::transaction_witness_set_redeemers_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_witness_set_redeemers(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSet.redeemers");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::transaction_witness_set_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_witness_set_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSet.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_witness_sets_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = transaction_witness_sets_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSets.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_witness_sets_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_witness_sets_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSets.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_witness_sets_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_witness_sets_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSets.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_witness_sets_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_witness_sets_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSets.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_witness_sets_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = transaction_witness_sets_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSets.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_witness_sets_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_witness_sets_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSets.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_witness_sets_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_witness_sets_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSets.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::transaction_witness_sets_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        transaction_witness_sets_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TransactionWitnessSets.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::transaction_witness_sets_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = transaction_witness_sets_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TransactionWitnessSets.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::transaction_witness_sets_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        transaction_witness_sets_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "TransactionWitnessSets.add");
    }

    std::string NativeCslMobileBridgeModule::treasury_withdrawals_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = treasury_withdrawals_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TreasuryWithdrawals.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::treasury_withdrawals_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = treasury_withdrawals_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TreasuryWithdrawals.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::treasury_withdrawals_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = treasury_withdrawals_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TreasuryWithdrawals.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::treasury_withdrawals_get_jsi(jsi::Runtime &rt, std::string self, std::string key) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = treasury_withdrawals_get(self_mapped, key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TreasuryWithdrawals.get");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::treasury_withdrawals_insert_jsi(jsi::Runtime &rt, std::string self, std::string key, std::string value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        RPtr value_mapped = stringToRptr(value);
        CharPtr err = nullptr;
        treasury_withdrawals_insert(self_mapped, key_mapped, value_mapped, &err);
        throw_if_error(rt, err, "TreasuryWithdrawals.insert");
    }

    std::string NativeCslMobileBridgeModule::treasury_withdrawals_keys_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = treasury_withdrawals_keys(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TreasuryWithdrawals.keys");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::treasury_withdrawals_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        treasury_withdrawals_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TreasuryWithdrawals.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::treasury_withdrawals_action_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = treasury_withdrawals_action_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "TreasuryWithdrawalsAction.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::treasury_withdrawals_action_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = treasury_withdrawals_action_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TreasuryWithdrawalsAction.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::treasury_withdrawals_action_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = treasury_withdrawals_action_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TreasuryWithdrawalsAction.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::treasury_withdrawals_action_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = treasury_withdrawals_action_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TreasuryWithdrawalsAction.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::treasury_withdrawals_action_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = treasury_withdrawals_action_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "TreasuryWithdrawalsAction.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::treasury_withdrawals_action_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = treasury_withdrawals_action_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TreasuryWithdrawalsAction.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::treasury_withdrawals_action_withdrawals_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = treasury_withdrawals_action_withdrawals(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TreasuryWithdrawalsAction.withdrawals");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::treasury_withdrawals_action_new_jsi(jsi::Runtime &rt, std::string withdrawals) {
        RPtr withdrawals_mapped = stringToRptr(withdrawals);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = treasury_withdrawals_action_new(withdrawals_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TreasuryWithdrawalsAction.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::tx_builder_constants_plutus_default_cost_models_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = tx_builder_constants_plutus_default_cost_models(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TxBuilderConstants.plutus_default_cost_models");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::tx_builder_constants_plutus_alonzo_cost_models_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = tx_builder_constants_plutus_alonzo_cost_models(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TxBuilderConstants.plutus_alonzo_cost_models");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::tx_builder_constants_plutus_vasil_cost_models_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = tx_builder_constants_plutus_vasil_cost_models(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TxBuilderConstants.plutus_vasil_cost_models");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::tx_inputs_builder_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = tx_inputs_builder_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TxInputsBuilder.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::tx_inputs_builder_add_key_input_jsi(jsi::Runtime &rt, std::string self, std::string hash, std::string input, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr hash_mapped = stringToRptr(hash);
        RPtr input_mapped = stringToRptr(input);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        tx_inputs_builder_add_key_input(self_mapped, hash_mapped, input_mapped, amount_mapped, &err);
        throw_if_error(rt, err, "TxInputsBuilder.add_key_input");
    }

    void NativeCslMobileBridgeModule::tx_inputs_builder_add_script_input_jsi(jsi::Runtime &rt, std::string self, std::string hash, std::string input, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr hash_mapped = stringToRptr(hash);
        RPtr input_mapped = stringToRptr(input);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        tx_inputs_builder_add_script_input(self_mapped, hash_mapped, input_mapped, amount_mapped, &err);
        throw_if_error(rt, err, "TxInputsBuilder.add_script_input");
    }

    void NativeCslMobileBridgeModule::tx_inputs_builder_add_native_script_input_jsi(jsi::Runtime &rt, std::string self, std::string script, std::string input, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr script_mapped = stringToRptr(script);
        RPtr input_mapped = stringToRptr(input);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        tx_inputs_builder_add_native_script_input(self_mapped, script_mapped, input_mapped, amount_mapped, &err);
        throw_if_error(rt, err, "TxInputsBuilder.add_native_script_input");
    }

    void NativeCslMobileBridgeModule::tx_inputs_builder_add_plutus_script_input_jsi(jsi::Runtime &rt, std::string self, std::string witness, std::string input, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr witness_mapped = stringToRptr(witness);
        RPtr input_mapped = stringToRptr(input);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        tx_inputs_builder_add_plutus_script_input(self_mapped, witness_mapped, input_mapped, amount_mapped, &err);
        throw_if_error(rt, err, "TxInputsBuilder.add_plutus_script_input");
    }

    void NativeCslMobileBridgeModule::tx_inputs_builder_add_bootstrap_input_jsi(jsi::Runtime &rt, std::string self, std::string hash, std::string input, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr hash_mapped = stringToRptr(hash);
        RPtr input_mapped = stringToRptr(input);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        tx_inputs_builder_add_bootstrap_input(self_mapped, hash_mapped, input_mapped, amount_mapped, &err);
        throw_if_error(rt, err, "TxInputsBuilder.add_bootstrap_input");
    }

    void NativeCslMobileBridgeModule::tx_inputs_builder_add_input_jsi(jsi::Runtime &rt, std::string self, std::string address, std::string input, std::string amount) {
        RPtr self_mapped = stringToRptr(self);
        RPtr address_mapped = stringToRptr(address);
        RPtr input_mapped = stringToRptr(input);
        RPtr amount_mapped = stringToRptr(amount);
        CharPtr err = nullptr;
        tx_inputs_builder_add_input(self_mapped, address_mapped, input_mapped, amount_mapped, &err);
        throw_if_error(rt, err, "TxInputsBuilder.add_input");
    }

    double NativeCslMobileBridgeModule::tx_inputs_builder_count_missing_input_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        tx_inputs_builder_count_missing_input_scripts(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TxInputsBuilder.count_missing_input_scripts");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::tx_inputs_builder_add_required_native_input_scripts_jsi(jsi::Runtime &rt, std::string self, std::string scripts) {
        RPtr self_mapped = stringToRptr(self);
        RPtr scripts_mapped = stringToRptr(scripts);
        CharPtr err = nullptr;
        int64_t ret;
        tx_inputs_builder_add_required_native_input_scripts(self_mapped, scripts_mapped, &ret, &err);
        throw_if_error(rt, err, "TxInputsBuilder.add_required_native_input_scripts");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::tx_inputs_builder_add_required_plutus_input_scripts_jsi(jsi::Runtime &rt, std::string self, std::string scripts) {
        RPtr self_mapped = stringToRptr(self);
        RPtr scripts_mapped = stringToRptr(scripts);
        CharPtr err = nullptr;
        int64_t ret;
        tx_inputs_builder_add_required_plutus_input_scripts(self_mapped, scripts_mapped, &ret, &err);
        throw_if_error(rt, err, "TxInputsBuilder.add_required_plutus_input_scripts");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::tx_inputs_builder_add_required_script_input_witnesses_jsi(jsi::Runtime &rt, std::string self, std::string inputs_with_wit) {
        RPtr self_mapped = stringToRptr(self);
        RPtr inputs_with_wit_mapped = stringToRptr(inputs_with_wit);
        CharPtr err = nullptr;
        int64_t ret;
        tx_inputs_builder_add_required_script_input_witnesses(self_mapped, inputs_with_wit_mapped, &ret, &err);
        throw_if_error(rt, err, "TxInputsBuilder.add_required_script_input_witnesses");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::tx_inputs_builder_get_ref_inputs_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = tx_inputs_builder_get_ref_inputs(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TxInputsBuilder.get_ref_inputs");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::tx_inputs_builder_get_native_input_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = tx_inputs_builder_get_native_input_scripts(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TxInputsBuilder.get_native_input_scripts");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::tx_inputs_builder_get_plutus_input_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = tx_inputs_builder_get_plutus_input_scripts(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TxInputsBuilder.get_plutus_input_scripts");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    double NativeCslMobileBridgeModule::tx_inputs_builder_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        tx_inputs_builder_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "TxInputsBuilder.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::tx_inputs_builder_add_required_signer_jsi(jsi::Runtime &rt, std::string self, std::string key) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        tx_inputs_builder_add_required_signer(self_mapped, key_mapped, &err);
        throw_if_error(rt, err, "TxInputsBuilder.add_required_signer");
    }

    void NativeCslMobileBridgeModule::tx_inputs_builder_add_required_signers_jsi(jsi::Runtime &rt, std::string self, std::string keys) {
        RPtr self_mapped = stringToRptr(self);
        RPtr keys_mapped = stringToRptr(keys);
        CharPtr err = nullptr;
        tx_inputs_builder_add_required_signers(self_mapped, keys_mapped, &err);
        throw_if_error(rt, err, "TxInputsBuilder.add_required_signers");
    }

    std::string NativeCslMobileBridgeModule::tx_inputs_builder_total_value_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = tx_inputs_builder_total_value(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TxInputsBuilder.total_value");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::tx_inputs_builder_inputs_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = tx_inputs_builder_inputs(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TxInputsBuilder.inputs");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::tx_inputs_builder_inputs_option_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = tx_inputs_builder_inputs_option(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "TxInputsBuilder.inputs_option");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::u_r_l_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = u_r_l_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "URL.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::u_r_l_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = u_r_l_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "URL.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::u_r_l_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = u_r_l_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "URL.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::u_r_l_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = u_r_l_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "URL.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::u_r_l_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = u_r_l_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "URL.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::u_r_l_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = u_r_l_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "URL.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::u_r_l_new_jsi(jsi::Runtime &rt, std::string url) {
        CharPtr url_mapped = stringToCharPtr(url);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = u_r_l_new(url_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "URL.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::u_r_l_url_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = u_r_l_url(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "URL.url");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::unit_interval_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = unit_interval_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "UnitInterval.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::unit_interval_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = unit_interval_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "UnitInterval.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::unit_interval_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = unit_interval_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "UnitInterval.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::unit_interval_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = unit_interval_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "UnitInterval.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::unit_interval_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = unit_interval_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "UnitInterval.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::unit_interval_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = unit_interval_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "UnitInterval.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::unit_interval_numerator_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = unit_interval_numerator(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "UnitInterval.numerator");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::unit_interval_denominator_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = unit_interval_denominator(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "UnitInterval.denominator");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::unit_interval_new_jsi(jsi::Runtime &rt, std::string numerator, std::string denominator) {
        RPtr numerator_mapped = stringToRptr(numerator);
        RPtr denominator_mapped = stringToRptr(denominator);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = unit_interval_new(numerator_mapped, denominator_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "UnitInterval.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = update_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Update.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = update_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Update.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = update_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Update.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = update_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Update.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = update_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Update.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = update_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Update.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_proposed_protocol_parameter_updates_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = update_proposed_protocol_parameter_updates(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Update.proposed_protocol_parameter_updates");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::update_epoch_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        update_epoch(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Update.epoch");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_new_jsi(jsi::Runtime &rt, std::string proposed_protocol_parameter_updates, double epoch) {
        RPtr proposed_protocol_parameter_updates_mapped = stringToRptr(proposed_protocol_parameter_updates);
        int64_t epoch_mapped = static_cast<int64_t>(epoch);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = update_new(proposed_protocol_parameter_updates_mapped, epoch_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Update.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_committee_action_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = update_committee_action_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "UpdateCommitteeAction.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_committee_action_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = update_committee_action_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "UpdateCommitteeAction.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_committee_action_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = update_committee_action_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "UpdateCommitteeAction.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_committee_action_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = update_committee_action_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "UpdateCommitteeAction.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_committee_action_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = update_committee_action_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "UpdateCommitteeAction.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_committee_action_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = update_committee_action_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "UpdateCommitteeAction.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::update_committee_action_gov_action_id_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = update_committee_action_gov_action_id(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "UpdateCommitteeAction.gov_action_id");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::update_committee_action_committee_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = update_committee_action_committee(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "UpdateCommitteeAction.committee");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_committee_action_members_to_remove_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = update_committee_action_members_to_remove(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "UpdateCommitteeAction.members_to_remove");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_committee_action_new_jsi(jsi::Runtime &rt, std::string committee, std::string members_to_remove) {
        RPtr committee_mapped = stringToRptr(committee);
        RPtr members_to_remove_mapped = stringToRptr(members_to_remove);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = update_committee_action_new(committee_mapped, members_to_remove_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "UpdateCommitteeAction.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::update_committee_action_new_with_action_id_jsi(jsi::Runtime &rt, std::string gov_action_id, std::string committee, std::string members_to_remove) {
        RPtr gov_action_id_mapped = stringToRptr(gov_action_id);
        RPtr committee_mapped = stringToRptr(committee);
        RPtr members_to_remove_mapped = stringToRptr(members_to_remove);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = update_committee_action_new_with_action_id(gov_action_id_mapped, committee_mapped, members_to_remove_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "UpdateCommitteeAction.new_with_action_id");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_cert_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = v_r_f_cert_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFCert.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_cert_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = v_r_f_cert_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFCert.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_cert_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = v_r_f_cert_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFCert.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_cert_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = v_r_f_cert_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFCert.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_cert_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = v_r_f_cert_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFCert.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_cert_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = v_r_f_cert_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFCert.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_cert_output_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = v_r_f_cert_output(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFCert.output");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_cert_proof_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = v_r_f_cert_proof(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFCert.proof");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_cert_new_jsi(jsi::Runtime &rt, std::string output, std::string proof) {
        auto output_mapped = base64ToBytes(output);
        auto proof_mapped = base64ToBytes(proof);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = v_r_f_cert_new(output_mapped.data(), output_mapped.size(), proof_mapped.data(), proof_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFCert.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_key_hash_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = v_r_f_key_hash_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFKeyHash.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_key_hash_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = v_r_f_key_hash_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFKeyHash.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_key_hash_to_bech32_jsi(jsi::Runtime &rt, std::string self, std::string prefix) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr prefix_mapped = stringToCharPtr(prefix);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = v_r_f_key_hash_to_bech32(self_mapped, prefix_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFKeyHash.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_key_hash_from_bech32_jsi(jsi::Runtime &rt, std::string bech_str) {
        CharPtr bech_str_mapped = stringToCharPtr(bech_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = v_r_f_key_hash_from_bech32(bech_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFKeyHash.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_key_hash_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = v_r_f_key_hash_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFKeyHash.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_key_hash_from_hex_jsi(jsi::Runtime &rt, std::string hex) {
        CharPtr hex_mapped = stringToCharPtr(hex);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = v_r_f_key_hash_from_hex(hex_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFKeyHash.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_v_key_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = v_r_f_v_key_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFVKey.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_v_key_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = v_r_f_v_key_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFVKey.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_v_key_to_bech32_jsi(jsi::Runtime &rt, std::string self, std::string prefix) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr prefix_mapped = stringToCharPtr(prefix);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = v_r_f_v_key_to_bech32(self_mapped, prefix_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFVKey.to_bech32");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_v_key_from_bech32_jsi(jsi::Runtime &rt, std::string bech_str) {
        CharPtr bech_str_mapped = stringToCharPtr(bech_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = v_r_f_v_key_from_bech32(bech_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFVKey.from_bech32");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_v_key_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = v_r_f_v_key_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFVKey.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::v_r_f_v_key_from_hex_jsi(jsi::Runtime &rt, std::string hex) {
        CharPtr hex_mapped = stringToCharPtr(hex);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = v_r_f_v_key_from_hex(hex_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VRFVKey.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::value_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = value_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Value.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::value_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = value_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Value.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::value_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = value_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Value.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::value_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = value_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Value.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::value_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = value_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Value.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::value_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = value_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Value.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::value_new_jsi(jsi::Runtime &rt, std::string coin) {
        RPtr coin_mapped = stringToRptr(coin);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = value_new(coin_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Value.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::value_new_from_assets_jsi(jsi::Runtime &rt, std::string multiasset) {
        RPtr multiasset_mapped = stringToRptr(multiasset);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = value_new_from_assets(multiasset_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Value.new_from_assets");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::value_new_with_assets_jsi(jsi::Runtime &rt, std::string coin, std::string multiasset) {
        RPtr coin_mapped = stringToRptr(coin);
        RPtr multiasset_mapped = stringToRptr(multiasset);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = value_new_with_assets(coin_mapped, multiasset_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Value.new_with_assets");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::value_zero_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = value_zero(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Value.zero");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::value_is_zero_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        value_is_zero(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Value.is_zero");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::value_coin_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = value_coin(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Value.coin");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::value_set_coin_jsi(jsi::Runtime &rt, std::string self, std::string coin) {
        RPtr self_mapped = stringToRptr(self);
        RPtr coin_mapped = stringToRptr(coin);
        CharPtr err = nullptr;
        value_set_coin(self_mapped, coin_mapped, &err);
        throw_if_error(rt, err, "Value.set_coin");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::value_multiasset_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = value_multiasset(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Value.multiasset");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    void NativeCslMobileBridgeModule::value_set_multiasset_jsi(jsi::Runtime &rt, std::string self, std::string multiasset) {
        RPtr self_mapped = stringToRptr(self);
        RPtr multiasset_mapped = stringToRptr(multiasset);
        CharPtr err = nullptr;
        value_set_multiasset(self_mapped, multiasset_mapped, &err);
        throw_if_error(rt, err, "Value.set_multiasset");
    }

    std::string NativeCslMobileBridgeModule::value_checked_add_jsi(jsi::Runtime &rt, std::string self, std::string rhs) {
        RPtr self_mapped = stringToRptr(self);
        RPtr rhs_mapped = stringToRptr(rhs);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = value_checked_add(self_mapped, rhs_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Value.checked_add");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::value_checked_sub_jsi(jsi::Runtime &rt, std::string self, std::string rhs_value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr rhs_value_mapped = stringToRptr(rhs_value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = value_checked_sub(self_mapped, rhs_value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Value.checked_sub");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::value_clamped_sub_jsi(jsi::Runtime &rt, std::string self, std::string rhs_value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr rhs_value_mapped = stringToRptr(rhs_value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = value_clamped_sub(self_mapped, rhs_value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Value.clamped_sub");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::optional<double> NativeCslMobileBridgeModule::value_compare_jsi(jsi::Runtime &rt, std::string self, std::string rhs_value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr rhs_value_mapped = stringToRptr(rhs_value);
        CharPtr err = nullptr;
        int64_t ret;
        bool has_ret = value_compare(self_mapped, rhs_value_mapped, &ret, &err);
        throw_if_error(rt, err, "Value.compare");
        if(has_ret) {
            auto mapped_ret = static_cast<double>(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::vkey_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = vkey_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkey.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkey_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkey_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkey.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkey_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = vkey_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkey.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkey_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkey_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkey.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkey_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = vkey_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkey.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkey_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkey_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkey.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkey_new_jsi(jsi::Runtime &rt, std::string pk) {
        RPtr pk_mapped = stringToRptr(pk);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkey_new(pk_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkey.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkey_public_key_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkey_public_key(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkey.public_key");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeys_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkeys_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeys.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::vkeys_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        vkeys_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Vkeys.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeys_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkeys_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeys.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::vkeys_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        vkeys_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "Vkeys.add");
    }

    std::string NativeCslMobileBridgeModule::vkeywitness_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = vkeywitness_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitness.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeywitness_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkeywitness_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitness.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeywitness_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = vkeywitness_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitness.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeywitness_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkeywitness_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitness.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeywitness_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = vkeywitness_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitness.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeywitness_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkeywitness_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitness.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeywitness_new_jsi(jsi::Runtime &rt, std::string vkey, std::string signature) {
        RPtr vkey_mapped = stringToRptr(vkey);
        RPtr signature_mapped = stringToRptr(signature);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkeywitness_new(vkey_mapped, signature_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitness.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeywitness_vkey_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkeywitness_vkey(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitness.vkey");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeywitness_signature_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkeywitness_signature(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitness.signature");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeywitnesses_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = vkeywitnesses_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitnesses.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeywitnesses_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkeywitnesses_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitnesses.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeywitnesses_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = vkeywitnesses_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitnesses.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeywitnesses_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkeywitnesses_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitnesses.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeywitnesses_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = vkeywitnesses_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitnesses.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeywitnesses_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkeywitnesses_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitnesses.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeywitnesses_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkeywitnesses_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitnesses.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::vkeywitnesses_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        vkeywitnesses_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Vkeywitnesses.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vkeywitnesses_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vkeywitnesses_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Vkeywitnesses.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::vkeywitnesses_add_jsi(jsi::Runtime &rt, std::string self, std::string elem) {
        RPtr self_mapped = stringToRptr(self);
        RPtr elem_mapped = stringToRptr(elem);
        CharPtr err = nullptr;
        vkeywitnesses_add(self_mapped, elem_mapped, &err);
        throw_if_error(rt, err, "Vkeywitnesses.add");
    }

    std::string NativeCslMobileBridgeModule::vote_delegation_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = vote_delegation_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteDelegation.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_delegation_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vote_delegation_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteDelegation.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_delegation_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = vote_delegation_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteDelegation.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_delegation_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vote_delegation_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteDelegation.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_delegation_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = vote_delegation_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteDelegation.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_delegation_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vote_delegation_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteDelegation.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_delegation_stake_credential_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vote_delegation_stake_credential(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteDelegation.stake_credential");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_delegation_drep_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vote_delegation_drep(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteDelegation.drep");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_delegation_new_jsi(jsi::Runtime &rt, std::string stake_credential, std::string drep) {
        RPtr stake_credential_mapped = stringToRptr(stake_credential);
        RPtr drep_mapped = stringToRptr(drep);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vote_delegation_new(stake_credential_mapped, drep_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteDelegation.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::vote_delegation_has_script_credentials_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        vote_delegation_has_script_credentials(self_mapped, &ret, &err);
        throw_if_error(rt, err, "VoteDelegation.has_script_credentials");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_registration_and_delegation_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = vote_registration_and_delegation_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteRegistrationAndDelegation.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_registration_and_delegation_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vote_registration_and_delegation_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteRegistrationAndDelegation.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_registration_and_delegation_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = vote_registration_and_delegation_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteRegistrationAndDelegation.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_registration_and_delegation_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vote_registration_and_delegation_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteRegistrationAndDelegation.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_registration_and_delegation_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = vote_registration_and_delegation_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteRegistrationAndDelegation.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_registration_and_delegation_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vote_registration_and_delegation_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteRegistrationAndDelegation.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_registration_and_delegation_stake_credential_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vote_registration_and_delegation_stake_credential(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteRegistrationAndDelegation.stake_credential");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_registration_and_delegation_drep_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vote_registration_and_delegation_drep(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteRegistrationAndDelegation.drep");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_registration_and_delegation_coin_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vote_registration_and_delegation_coin(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteRegistrationAndDelegation.coin");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::vote_registration_and_delegation_new_jsi(jsi::Runtime &rt, std::string stake_credential, std::string drep, std::string coin) {
        RPtr stake_credential_mapped = stringToRptr(stake_credential);
        RPtr drep_mapped = stringToRptr(drep);
        RPtr coin_mapped = stringToRptr(coin);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = vote_registration_and_delegation_new(stake_credential_mapped, drep_mapped, coin_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VoteRegistrationAndDelegation.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::vote_registration_and_delegation_has_script_credentials_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        vote_registration_and_delegation_has_script_credentials(self_mapped, &ret, &err);
        throw_if_error(rt, err, "VoteRegistrationAndDelegation.has_script_credentials");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voter_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = voter_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Voter.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voter_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voter_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Voter.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voter_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = voter_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Voter.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voter_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voter_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Voter.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voter_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = voter_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Voter.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voter_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voter_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Voter.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voter_new_constitutional_committee_hot_key_jsi(jsi::Runtime &rt, std::string cred) {
        RPtr cred_mapped = stringToRptr(cred);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voter_new_constitutional_committee_hot_key(cred_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Voter.new_constitutional_committee_hot_key");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voter_new_drep_jsi(jsi::Runtime &rt, std::string cred) {
        RPtr cred_mapped = stringToRptr(cred);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voter_new_drep(cred_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Voter.new_drep");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voter_new_staking_pool_jsi(jsi::Runtime &rt, std::string key_hash) {
        RPtr key_hash_mapped = stringToRptr(key_hash);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voter_new_staking_pool(key_hash_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Voter.new_staking_pool");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::voter_kind_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int32_t ret;
        voter_kind(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Voter.kind");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::voter_to_constitutional_committee_hot_cred_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voter_to_constitutional_committee_hot_cred(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Voter.to_constitutional_committee_hot_cred");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::voter_to_drep_cred_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voter_to_drep_cred(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Voter.to_drep_cred");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::voter_to_staking_pool_key_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voter_to_staking_pool_key_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Voter.to_staking_pool_key_hash");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    bool NativeCslMobileBridgeModule::voter_has_script_credentials_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        voter_has_script_credentials(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Voter.has_script_credentials");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::voter_to_key_hash_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voter_to_key_hash(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Voter.to_key_hash");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::voters_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = voters_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Voters.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voters_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voters_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Voters.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voters_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voters_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Voters.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::voters_add_jsi(jsi::Runtime &rt, std::string self, std::string voter) {
        RPtr self_mapped = stringToRptr(self);
        RPtr voter_mapped = stringToRptr(voter);
        CharPtr err = nullptr;
        voters_add(self_mapped, voter_mapped, &err);
        throw_if_error(rt, err, "Voters.add");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::voters_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voters_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Voters.get");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    double NativeCslMobileBridgeModule::voters_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        voters_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Voters.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_builder_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_builder_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingBuilder.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::voting_builder_add_jsi(jsi::Runtime &rt, std::string self, std::string voter, std::string gov_action_id, std::string voting_procedure) {
        RPtr self_mapped = stringToRptr(self);
        RPtr voter_mapped = stringToRptr(voter);
        RPtr gov_action_id_mapped = stringToRptr(gov_action_id);
        RPtr voting_procedure_mapped = stringToRptr(voting_procedure);
        CharPtr err = nullptr;
        voting_builder_add(self_mapped, voter_mapped, gov_action_id_mapped, voting_procedure_mapped, &err);
        throw_if_error(rt, err, "VotingBuilder.add");
    }

    void NativeCslMobileBridgeModule::voting_builder_add_with_plutus_witness_jsi(jsi::Runtime &rt, std::string self, std::string voter, std::string gov_action_id, std::string voting_procedure, std::string witness) {
        RPtr self_mapped = stringToRptr(self);
        RPtr voter_mapped = stringToRptr(voter);
        RPtr gov_action_id_mapped = stringToRptr(gov_action_id);
        RPtr voting_procedure_mapped = stringToRptr(voting_procedure);
        RPtr witness_mapped = stringToRptr(witness);
        CharPtr err = nullptr;
        voting_builder_add_with_plutus_witness(self_mapped, voter_mapped, gov_action_id_mapped, voting_procedure_mapped, witness_mapped, &err);
        throw_if_error(rt, err, "VotingBuilder.add_with_plutus_witness");
    }

    void NativeCslMobileBridgeModule::voting_builder_add_with_native_script_jsi(jsi::Runtime &rt, std::string self, std::string voter, std::string gov_action_id, std::string voting_procedure, std::string native_script_source) {
        RPtr self_mapped = stringToRptr(self);
        RPtr voter_mapped = stringToRptr(voter);
        RPtr gov_action_id_mapped = stringToRptr(gov_action_id);
        RPtr voting_procedure_mapped = stringToRptr(voting_procedure);
        RPtr native_script_source_mapped = stringToRptr(native_script_source);
        CharPtr err = nullptr;
        voting_builder_add_with_native_script(self_mapped, voter_mapped, gov_action_id_mapped, voting_procedure_mapped, native_script_source_mapped, &err);
        throw_if_error(rt, err, "VotingBuilder.add_with_native_script");
    }

    std::string NativeCslMobileBridgeModule::voting_builder_get_plutus_witnesses_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_builder_get_plutus_witnesses(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingBuilder.get_plutus_witnesses");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_builder_get_ref_inputs_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_builder_get_ref_inputs(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingBuilder.get_ref_inputs");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_builder_get_native_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_builder_get_native_scripts(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingBuilder.get_native_scripts");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::voting_builder_has_plutus_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        voting_builder_has_plutus_scripts(self_mapped, &ret, &err);
        throw_if_error(rt, err, "VotingBuilder.has_plutus_scripts");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_builder_build_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_builder_build(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingBuilder.build");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_procedure_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = voting_procedure_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedure.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_procedure_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_procedure_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedure.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_procedure_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = voting_procedure_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedure.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_procedure_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_procedure_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedure.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_procedure_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = voting_procedure_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedure.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_procedure_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_procedure_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedure.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_procedure_new_jsi(jsi::Runtime &rt, double vote) {
        int32_t vote_mapped = static_cast<int32_t>(vote);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_procedure_new(vote_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedure.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_procedure_new_with_anchor_jsi(jsi::Runtime &rt, double vote, std::string anchor) {
        int32_t vote_mapped = static_cast<int32_t>(vote);
        RPtr anchor_mapped = stringToRptr(anchor);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_procedure_new_with_anchor(vote_mapped, anchor_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedure.new_with_anchor");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::voting_procedure_vote_kind_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int32_t ret;
        voting_procedure_vote_kind(self_mapped, &ret, &err);
        throw_if_error(rt, err, "VotingProcedure.vote_kind");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::voting_procedure_anchor_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_procedure_anchor(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedure.anchor");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::voting_procedures_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = voting_procedures_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedures.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_procedures_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_procedures_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedures.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_procedures_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = voting_procedures_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedures.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_procedures_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_procedures_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedures.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_procedures_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = voting_procedures_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedures.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_procedures_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_procedures_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedures.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_procedures_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_procedures_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedures.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::voting_procedures_insert_jsi(jsi::Runtime &rt, std::string self, std::string voter, std::string governance_action_id, std::string voting_procedure) {
        RPtr self_mapped = stringToRptr(self);
        RPtr voter_mapped = stringToRptr(voter);
        RPtr governance_action_id_mapped = stringToRptr(governance_action_id);
        RPtr voting_procedure_mapped = stringToRptr(voting_procedure);
        CharPtr err = nullptr;
        voting_procedures_insert(self_mapped, voter_mapped, governance_action_id_mapped, voting_procedure_mapped, &err);
        throw_if_error(rt, err, "VotingProcedures.insert");
    }

    std::optional<std::string> NativeCslMobileBridgeModule::voting_procedures_get_jsi(jsi::Runtime &rt, std::string self, std::string voter, std::string governance_action_id) {
        RPtr self_mapped = stringToRptr(self);
        RPtr voter_mapped = stringToRptr(voter);
        RPtr governance_action_id_mapped = stringToRptr(governance_action_id);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_procedures_get(self_mapped, voter_mapped, governance_action_id_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedures.get");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::voting_procedures_get_voters_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_procedures_get_voters(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedures.get_voters");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_procedures_get_governance_action_ids_by_voter_jsi(jsi::Runtime &rt, std::string self, std::string voter) {
        RPtr self_mapped = stringToRptr(self);
        RPtr voter_mapped = stringToRptr(voter);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_procedures_get_governance_action_ids_by_voter(self_mapped, voter_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProcedures.get_governance_action_ids_by_voter");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposal_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = voting_proposal_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposal.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposal_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposal_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposal.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposal_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = voting_proposal_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposal.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposal_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposal_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposal.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposal_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = voting_proposal_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposal.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposal_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposal_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposal.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposal_governance_action_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposal_governance_action(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposal.governance_action");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposal_anchor_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposal_anchor(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposal.anchor");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposal_reward_account_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposal_reward_account(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposal.reward_account");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposal_deposit_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposal_deposit(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposal.deposit");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposal_new_jsi(jsi::Runtime &rt, std::string governance_action, std::string anchor, std::string reward_account, std::string deposit) {
        RPtr governance_action_mapped = stringToRptr(governance_action);
        RPtr anchor_mapped = stringToRptr(anchor);
        RPtr reward_account_mapped = stringToRptr(reward_account);
        RPtr deposit_mapped = stringToRptr(deposit);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposal_new(governance_action_mapped, anchor_mapped, reward_account_mapped, deposit_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposal.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposal_builder_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposal_builder_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposalBuilder.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::voting_proposal_builder_add_jsi(jsi::Runtime &rt, std::string self, std::string proposal) {
        RPtr self_mapped = stringToRptr(self);
        RPtr proposal_mapped = stringToRptr(proposal);
        CharPtr err = nullptr;
        voting_proposal_builder_add(self_mapped, proposal_mapped, &err);
        throw_if_error(rt, err, "VotingProposalBuilder.add");
    }

    void NativeCslMobileBridgeModule::voting_proposal_builder_add_with_plutus_witness_jsi(jsi::Runtime &rt, std::string self, std::string proposal, std::string witness) {
        RPtr self_mapped = stringToRptr(self);
        RPtr proposal_mapped = stringToRptr(proposal);
        RPtr witness_mapped = stringToRptr(witness);
        CharPtr err = nullptr;
        voting_proposal_builder_add_with_plutus_witness(self_mapped, proposal_mapped, witness_mapped, &err);
        throw_if_error(rt, err, "VotingProposalBuilder.add_with_plutus_witness");
    }

    std::string NativeCslMobileBridgeModule::voting_proposal_builder_get_plutus_witnesses_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposal_builder_get_plutus_witnesses(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposalBuilder.get_plutus_witnesses");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposal_builder_get_ref_inputs_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposal_builder_get_ref_inputs(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposalBuilder.get_ref_inputs");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::voting_proposal_builder_has_plutus_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        voting_proposal_builder_has_plutus_scripts(self_mapped, &ret, &err);
        throw_if_error(rt, err, "VotingProposalBuilder.has_plutus_scripts");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposal_builder_build_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposal_builder_build(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposalBuilder.build");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposals_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = voting_proposals_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposals.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposals_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposals_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposals.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposals_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = voting_proposals_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposals.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposals_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposals_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposals.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposals_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = voting_proposals_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposals.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposals_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposals_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposals.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposals_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposals_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposals.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::voting_proposals_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        voting_proposals_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "VotingProposals.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::voting_proposals_get_jsi(jsi::Runtime &rt, std::string self, double index) {
        RPtr self_mapped = stringToRptr(self);
        int64_t index_mapped = static_cast<int64_t>(index);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = voting_proposals_get(self_mapped, index_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "VotingProposals.get");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::voting_proposals_add_jsi(jsi::Runtime &rt, std::string self, std::string proposal) {
        RPtr self_mapped = stringToRptr(self);
        RPtr proposal_mapped = stringToRptr(proposal);
        CharPtr err = nullptr;
        voting_proposals_add(self_mapped, proposal_mapped, &err);
        throw_if_error(rt, err, "VotingProposals.add");
    }

    std::string NativeCslMobileBridgeModule::withdrawals_to_bytes_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        DataPtr ret;
        bool has_ret = withdrawals_to_bytes(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                dataptr_free(&ret);
            }
            throw_if_error(rt, err, "Withdrawals.to_bytes");
        }
        auto mapped_ret = dataPtrToBase64(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::withdrawals_from_bytes_jsi(jsi::Runtime &rt, std::string bytes) {
        auto bytes_mapped = base64ToBytes(bytes);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = withdrawals_from_bytes(bytes_mapped.data(), bytes_mapped.size(), &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Withdrawals.from_bytes");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::withdrawals_to_hex_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = withdrawals_to_hex(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Withdrawals.to_hex");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::withdrawals_from_hex_jsi(jsi::Runtime &rt, std::string hex_str) {
        CharPtr hex_str_mapped = stringToCharPtr(hex_str);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = withdrawals_from_hex(hex_str_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Withdrawals.from_hex");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::withdrawals_to_json_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        CharPtr ret;
        bool has_ret = withdrawals_to_json(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                charptr_free(&ret);
            }
            throw_if_error(rt, err, "Withdrawals.to_json");
        }
        auto mapped_ret = charPtrToString(&ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::withdrawals_from_json_jsi(jsi::Runtime &rt, std::string json) {
        CharPtr json_mapped = stringToCharPtr(json);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = withdrawals_from_json(json_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Withdrawals.from_json");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::withdrawals_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = withdrawals_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Withdrawals.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    double NativeCslMobileBridgeModule::withdrawals_len_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        int64_t ret;
        withdrawals_len(self_mapped, &ret, &err);
        throw_if_error(rt, err, "Withdrawals.len");
        auto mapped_ret = static_cast<double>(ret);
        return mapped_ret;
    }

    std::optional<std::string> NativeCslMobileBridgeModule::withdrawals_insert_jsi(jsi::Runtime &rt, std::string self, std::string key, std::string value) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        RPtr value_mapped = stringToRptr(value);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = withdrawals_insert(self_mapped, key_mapped, value_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Withdrawals.insert");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::optional<std::string> NativeCslMobileBridgeModule::withdrawals_get_jsi(jsi::Runtime &rt, std::string self, std::string key) {
        RPtr self_mapped = stringToRptr(self);
        RPtr key_mapped = stringToRptr(key);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = withdrawals_get(self_mapped, key_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Withdrawals.get");
        }
        if(has_ret) {
            auto mapped_ret = rptrToString(ret);
            return mapped_ret;
        } else {
            return std::nullopt;
        }
    }

    std::string NativeCslMobileBridgeModule::withdrawals_keys_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = withdrawals_keys(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "Withdrawals.keys");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::withdrawals_builder_new_jsi(jsi::Runtime &rt) {
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = withdrawals_builder_new(&ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "WithdrawalsBuilder.new");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    void NativeCslMobileBridgeModule::withdrawals_builder_add_jsi(jsi::Runtime &rt, std::string self, std::string address, std::string coin) {
        RPtr self_mapped = stringToRptr(self);
        RPtr address_mapped = stringToRptr(address);
        RPtr coin_mapped = stringToRptr(coin);
        CharPtr err = nullptr;
        withdrawals_builder_add(self_mapped, address_mapped, coin_mapped, &err);
        throw_if_error(rt, err, "WithdrawalsBuilder.add");
    }

    void NativeCslMobileBridgeModule::withdrawals_builder_add_with_plutus_witness_jsi(jsi::Runtime &rt, std::string self, std::string address, std::string coin, std::string witness) {
        RPtr self_mapped = stringToRptr(self);
        RPtr address_mapped = stringToRptr(address);
        RPtr coin_mapped = stringToRptr(coin);
        RPtr witness_mapped = stringToRptr(witness);
        CharPtr err = nullptr;
        withdrawals_builder_add_with_plutus_witness(self_mapped, address_mapped, coin_mapped, witness_mapped, &err);
        throw_if_error(rt, err, "WithdrawalsBuilder.add_with_plutus_witness");
    }

    void NativeCslMobileBridgeModule::withdrawals_builder_add_with_native_script_jsi(jsi::Runtime &rt, std::string self, std::string address, std::string coin, std::string native_script_source) {
        RPtr self_mapped = stringToRptr(self);
        RPtr address_mapped = stringToRptr(address);
        RPtr coin_mapped = stringToRptr(coin);
        RPtr native_script_source_mapped = stringToRptr(native_script_source);
        CharPtr err = nullptr;
        withdrawals_builder_add_with_native_script(self_mapped, address_mapped, coin_mapped, native_script_source_mapped, &err);
        throw_if_error(rt, err, "WithdrawalsBuilder.add_with_native_script");
    }

    std::string NativeCslMobileBridgeModule::withdrawals_builder_get_plutus_witnesses_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = withdrawals_builder_get_plutus_witnesses(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "WithdrawalsBuilder.get_plutus_witnesses");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::withdrawals_builder_get_ref_inputs_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = withdrawals_builder_get_ref_inputs(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "WithdrawalsBuilder.get_ref_inputs");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::withdrawals_builder_get_native_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = withdrawals_builder_get_native_scripts(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "WithdrawalsBuilder.get_native_scripts");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::withdrawals_builder_get_total_withdrawals_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = withdrawals_builder_get_total_withdrawals(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "WithdrawalsBuilder.get_total_withdrawals");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

    bool NativeCslMobileBridgeModule::withdrawals_builder_has_plutus_scripts_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        bool ret;
        withdrawals_builder_has_plutus_scripts(self_mapped, &ret, &err);
        throw_if_error(rt, err, "WithdrawalsBuilder.has_plutus_scripts");
        auto mapped_ret = static_cast<bool>(ret);
        return mapped_ret;
    }

    std::string NativeCslMobileBridgeModule::withdrawals_builder_build_jsi(jsi::Runtime &rt, std::string self) {
        RPtr self_mapped = stringToRptr(self);
        CharPtr err = nullptr;
        RPtr ret;
        bool has_ret = withdrawals_builder_build(self_mapped, &ret, &err);
        if(err != nullptr) {
            if(has_ret) {
                rptr_free(&ret);
            }
            throw_if_error(rt, err, "WithdrawalsBuilder.build");
        }
        auto mapped_ret = rptrToString(ret);
        return mapped_ret;
    }

}// namespace facebook::react
